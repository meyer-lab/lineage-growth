<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Shakthi Visagan" />
  <meta name="author" content="Farnaz Mohammadi" />
  <meta name="author" content="Sean M. Gross" />
  <meta name="author" content="Luka Karginov" />
  <meta name="author" content="JC Lagarde" />
  <meta name="author" content="Laura M. Heiser" />
  <meta name="author" content="Aaron S. Meyer" />
  <meta name="dcterms.date" content="2021-01-30" />
  <meta name="keywords" content="cancer, heterogeneity, lineage, hidden Markov model" />
  <title>A lineage tree-based hidden Markov model to quantify cellular heterogeneity</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--
  Manubot generated metadata rendered from header-includes-template.html.
  Suggest improvements at https://github.com/manubot/manubot/blob/master/manubot/process/header-includes-template.html
  -->
  <meta name="dc.format" content="text/html" />
  <meta name="dc.title" content="A lineage tree-based hidden Markov model to quantify cellular heterogeneity" />
  <meta name="citation_title" content="A lineage tree-based hidden Markov model to quantify cellular heterogeneity" />
  <meta property="og:title" content="A lineage tree-based hidden Markov model to quantify cellular heterogeneity" />
  <meta property="twitter:title" content="A lineage tree-based hidden Markov model to quantify cellular heterogeneity" />
  <meta name="dc.date" content="2021-01-30" />
  <meta name="citation_publication_date" content="2021-01-30" />
  <meta name="dc.language" content="en-US" />
  <meta name="citation_language" content="en-US" />
  <meta name="dc.relation.ispartof" content="Manubot" />
  <meta name="dc.publisher" content="Manubot" />
  <meta name="citation_journal_title" content="Manubot" />
  <meta name="citation_technical_report_institution" content="Manubot" />
  <meta name="citation_author" content="Shakthi Visagan" />
  <meta name="citation_author_institution" content="Department of Bioengineering, University of California, Los Angeles" />
  <meta name="citation_author_orcid" content="0000-0001-9295-2188" />
  <meta name="citation_author" content="Farnaz Mohammadi" />
  <meta name="citation_author_institution" content="Department of Bioengineering, University of California, Los Angeles" />
  <meta name="citation_author_orcid" content="0000-0002-0197-4670" />
  <meta name="citation_author" content="Sean M. Gross" />
  <meta name="citation_author_institution" content="Department of Biomedical Engineering, Oregon Health and Science University, Portland" />
  <meta name="citation_author_orcid" content="0000-0002-9621-8551" />
  <meta name="citation_author" content="Luka Karginov" />
  <meta name="citation_author_institution" content="Department of Bioengineering, University of Illinois, Urbana Champaign" />
  <meta name="citation_author_orcid" content="0000-0002-2455-1558" />
  <meta name="citation_author" content="JC Lagarde" />
  <meta name="citation_author_institution" content="Department of Bioengineering, University of California, Los Angeles" />
  <meta name="citation_author_orcid" content="0000-0002-3738-3119" />
  <meta name="citation_author" content="Laura M. Heiser" />
  <meta name="citation_author_institution" content="Department of Biomedical Engineering, Oregon Health and Science University, Portland" />
  <meta name="citation_author" content="Aaron S. Meyer" />
  <meta name="citation_author_institution" content="Department of Bioengineering, University of California, Los Angeles" />
  <meta name="citation_author_institution" content="Department of Bioinformatics, University of California, Los Angeles" />
  <meta name="citation_author_institution" content="Jonsson Comprehensive Cancer Center, University of California, Los Angeles" />
  <meta name="citation_author_institution" content="Eli and Edythe Broad Center of Regenerative Medicine and Stem Cell Research, University of California, Los Angeles" />
  <meta name="citation_author_orcid" content="0000-0003-4513-1840" />
  <meta name="twitter:creator" content="@aarmey" />
  <link rel="canonical" href="https://meyer-lab.github.io/tHMM/" />
  <meta property="og:url" content="https://meyer-lab.github.io/tHMM/" />
  <meta property="twitter:url" content="https://meyer-lab.github.io/tHMM/" />
  <meta name="citation_fulltext_html_url" content="https://meyer-lab.github.io/tHMM/" />
  <meta name="citation_pdf_url" content="https://meyer-lab.github.io/tHMM/manuscript.pdf" />
  <link rel="alternate" type="application/pdf" href="https://meyer-lab.github.io/tHMM/manuscript.pdf" />
  <link rel="alternate" type="text/html" href="https://meyer-lab.github.io/tHMM/v/55f56a7d36bb00f341817bbdf004934bda4ac8a9/" />
  <meta name="manubot_html_url_versioned" content="https://meyer-lab.github.io/tHMM/v/55f56a7d36bb00f341817bbdf004934bda4ac8a9/" />
  <meta name="manubot_pdf_url_versioned" content="https://meyer-lab.github.io/tHMM/v/55f56a7d36bb00f341817bbdf004934bda4ac8a9/manuscript.pdf" />
  <meta property="og:type" content="article" />
  <meta property="twitter:card" content="summary_large_image" />
  <link rel="icon" type="image/png" sizes="192x192" href="https://manubot.org/favicon-192x192.png" />
  <link rel="mask-icon" href="https://manubot.org/safari-pinned-tab.svg" color="#ad1457" />
  <meta name="theme-color" content="#ad1457" />
  <!-- end Manubot generated metadata -->
</head>
<body>
<header id="title-block-header">
<h1 class="title">A lineage tree-based hidden Markov model to quantify cellular heterogeneity</h1>
</header>
<p><small><em>
This manuscript
was automatically generated on January 30, 2021.
</em></small></p>
<h2 id="authors">Authors</h2>
<ul>
<li><p><strong>Shakthi Visagan</strong><br>
ORCID
<a href="https://orcid.org/0000-0001-9295-2188">0000-0001-9295-2188</a>
· Github
<a href="https://github.com/shak360">shak360</a><br>
<small>
Department of Bioengineering, University of California, Los Angeles
</small></p></li>
<li><p><strong>Farnaz Mohammadi</strong><br>
ORCID
<a href="https://orcid.org/0000-0002-0197-4670">0000-0002-0197-4670</a>
· Github
<a href="https://github.com/farnazmdi">farnazmdi</a><br>
<small>
Department of Bioengineering, University of California, Los Angeles
</small></p></li>
<li><p><strong>Sean M. Gross</strong><br>
ORCID
<a href="https://orcid.org/0000-0002-9621-8551">0000-0002-9621-8551</a><br>
<small>
Department of Biomedical Engineering, Oregon Health and Science University, Portland
</small></p></li>
<li><p><strong>Luka Karginov</strong><br>
ORCID
<a href="https://orcid.org/0000-0002-2455-1558">0000-0002-2455-1558</a>
· Github
<a href="https://github.com/lkargi">lkargi</a><br>
<small>
Department of Bioengineering, University of Illinois, Urbana Champaign
</small></p></li>
<li><p><strong>JC Lagarde</strong><br>
ORCID
<a href="https://orcid.org/0000-0002-3738-3119">0000-0002-3738-3119</a>
· Github
<a href="https://github.com/jclagarde">jclagarde</a><br>
<small>
Department of Bioengineering, University of California, Los Angeles
</small></p></li>
<li><p><strong>Laura M. Heiser</strong><br><br>
<small>
Department of Biomedical Engineering, Oregon Health and Science University, Portland
</small></p></li>
<li><p><strong>Aaron S. Meyer</strong><br>
ORCID
<a href="https://orcid.org/0000-0003-4513-1840">0000-0003-4513-1840</a>
· Github
<a href="https://github.com/aarmey">aarmey</a>
· twitter
<a href="https://twitter.com/aarmey">aarmey</a><br>
<small>
Department of Bioengineering, University of California, Los Angeles; Department of Bioinformatics, University of California, Los Angeles; Jonsson Comprehensive Cancer Center, University of California, Los Angeles; Eli and Edythe Broad Center of Regenerative Medicine and Stem Cell Research, University of California, Los Angeles
</small></p></li>
</ul>
<h2 class="page_break_before" id="abstract">Abstract</h2>
<p>Cell plasticity, or the ability of cells within a population to reversibly alter epigenetic state, is an important feature of tissue homeostasis during processes such as wound healing and is dysregulated in cancer. Plasticity is further linked to other sources of cell-to-cell heterogeneity, or diversity in cell state, including genetic mutations and variation in signaling during drug-resistance development. Ultimately these processes prevent most cancer therapies from being curative. The predominant methods of quantifying tumor-drug response operate on population-level measurements and therefore lack evolutionary dynamics, which are particularly critical for highly dynamic processes such as plasticity. Here, we apply a tree-based adaptation of a hidden Markov model (tHMM) that employs single-cell lineages as input, to learn the characteristic patterns of single-cell heterogeneity and state transitions in an unsupervised fashion. This model enables single-cell classification based on the phenotype of individual cells and their relatives for improved specificity when pinpointing the molecular drivers of variability in drug response. Integrating this model with a modular interface for defining observed phenotypes allows the model to easily be adapted to any phenotype measured in single cells. We paired cell fate with either cell lifetimes or cell cycle phase lengths (G1 and S/G2) as our observed phenotypes on synthetic data and demonstrated that the model successfully classifies cells within experimentally-tractable dataset sizes. As an application, we analyzed experimental measurements of cell fate and phase duration in cancer cell populations to determine the number of distinct subpopulations. In total, this tHMM framework allows for the flexible classification of single-cell heterogeneity across lineages.</p>
<h2 id="summary-points">Summary points</h2>
<ul>
<li>A lineage tree-based hidden Markov model (tHMM) quantifies cell-to-cell variability and dynamic population changes.</li>
<li>A modular interface to define phenotypes allows the model to work with a wide variety of measurements.</li>
<li>The model accurately classifies cells within experimentally tractable dataset sizes.</li>
<li>Classifying cells based on their phenotypic heterogeneity can uncover resistance mechanisms hidden at the population level.</li>
</ul>
<h2 id="author-summary">Author Summary</h2>
<p>Heterogeneous traits, such as resistance or susceptibility to a drug, can be correlated in related cells because of partially inherited factors. These acquired traits may be the result of the microenvironment, epigenetics, or mutations. Using cell’s relationships we capture these dynamic transitions between different cell states and arrive at a more accurate quantification of cell heterogeneity within tumor populations. Our computational approach employing a modified hidden Markov model provides greater specificity by identifying intratumor resistance on a single cell level based on lineage histories and can identify dynamic changes in population structure upon treatment.</p>
<h2 id="introduction">Introduction</h2>
<!-- motivation; heterogeneity is an obstacle for chemotherapy  -->
<p>One of the primary treatments of cancer consists of chemotherapy, mainly targeted therapies, whereby patients are administered drugs that eliminate fast-proliferating cells to stall cancer growth or eliminate the tumor. Long-term therapeutic efficacy, however, varies significantly due to the vast heterogeneity in intratumor response to therapy.<span class="citation" data-cites="wEXyiydz h29ZM4mv"><sup><a href="#ref-wEXyiydz" role="doc-biblioref">1</a>,<a href="#ref-h29ZM4mv" role="doc-biblioref">2</a></sup></span> Cell variability in drug response can originate from cell-intrinsic factors, such as genomic alterations (i.e., altered nucleotide excision repair, telomere maintenance, and copy-number variation) and epigenetic mechanisms like changes in a chromatin state,<span class="citation" data-cites="1AGMG5i1a"><sup><a href="#ref-1AGMG5i1a" role="doc-biblioref">3</a></sup></span> or cell-extrinsic factors such as spatial variability in the surrounding vasculature and environmental stressors.<span class="citation" data-cites="jHXzaoNt 79g6Efbb 8PjsI84U"><sup><a href="#ref-jHXzaoNt" role="doc-biblioref">4</a>–<a href="#ref-8PjsI84U" role="doc-biblioref">6</a></sup></span> Moreover, cell plasticity is observed more often in cancer cells where they take over the characteristics of other cell subttypes which could directly affect their sensitivity to the therapeutic compounds.<span class="citation" data-cites="m4Kq0IiR"><sup><a href="#ref-m4Kq0IiR" role="doc-biblioref">7</a></sup></span></p>
<!-- literature review in conventional single-cell variability studies -->
<p>Advances in ‘omics’ technologies have enabled detailed analysis of cell-to-cell variability,<span class="citation" data-cites="h29ZM4mv 1EmZp72ZM"><sup><a href="#ref-h29ZM4mv" role="doc-biblioref">2</a>,<a href="#ref-1EmZp72ZM" role="doc-biblioref">8</a></sup></span> and the development of fine mapping and protein network algorithms have determined the presence of causal genetic mutations and dysregulation events that drive abnormal protein function.<span class="citation" data-cites="arjISkeW 5liODcji"><sup><a href="#ref-arjISkeW" role="doc-biblioref">9</a>,<a href="#ref-5liODcji" role="doc-biblioref">10</a></sup></span> These modalities, however, are labor and time-intensive, do not account for environmental factors, and serve primarily as end-point analysis barring longitudinal observation of tumor evolution. In addition to ‘omics’ modalities, genetic <em>association</em> studies (i.e., Cancer Cell Line Encyclopedia) are similarly able to find common risk factors with smaller effect sizes using population-level samples. The findings are valuable but fail to identify rare and meaningful transitions on the single-cell level,<span class="citation" data-cites="4Owum1Lv"><sup><a href="#ref-4Owum1Lv" role="doc-biblioref">11</a></sup></span> in particular the stochastic changes in individual cell states that have significant effects on overall tumor resistance. Lastly, fitness markers such as cell end-of-life fate, lifetime, and population doubling time are adopted in the clinical setting to measure cell pathologies.<span class="citation" data-cites="od9oxYIw tAijMuLh Ys7Kc53C 17XnDKTPF"><sup><a href="#ref-od9oxYIw" role="doc-biblioref">12</a>–<a href="#ref-17XnDKTPF" role="doc-biblioref">15</a></sup></span> Recent research has made efforts to track phenotypic measurements of fitness at the single-cell level;<span class="citation" data-cites="gckaWBL7 1ETBBN4au"><sup><a href="#ref-gckaWBL7" role="doc-biblioref">16</a>,<a href="#ref-1ETBBN4au" role="doc-biblioref">17</a></sup></span> however, most efforts are not yet resolved enough to illuminate the full complexity of cancer cells due in large part to reliance on population-level analysis (i.e., IC<sub>50</sub>).<span class="citation" data-cites="15TlHMr6M"><sup><a href="#ref-15TlHMr6M" role="doc-biblioref">18</a></sup></span></p>
<!-- Lineage data is special -->
<p>Measurements accompanied by lineage relationships are uniquely valuable for studying inherited phenotypes within families of people or populations of cells. This value is well-recognized in linkage studies which use pairs of relatives to identify the genetic determinants of disease.<span class="citation" data-cites="xFOIrC99"><sup><a href="#ref-xFOIrC99" role="doc-biblioref">19</a></sup></span> Notably, linkage studies can identify genetic determinants with greater power than even much larger correlation-based studies because relatives essentially serve as internal controls (CITE REVIEW). Linkage studies also start with the phenotype of individuals, rather than grouping based on molecular differences as is most common in cells. Lineage-resolved data has demonstrated unique value in cells for uncovering heterogeneity due to transient differences.<span class="citation" data-cites="EhD8XBE4 1EqKfJscv"><sup><a href="#ref-EhD8XBE4" role="doc-biblioref">20</a>,<a href="#ref-1EqKfJscv" role="doc-biblioref">21</a></sup></span></p>
<!-- tHMMs are a solution to modeling lineage data -->
<p>Hidden Markov models (HMMs) provide a strategy to infer discrete states from measurements when a series of co-dependent observations are made. An example of this is their most widely-used application—time series data—where each measurement is dependent on what came before. Recognizing this co-dependence allows HMMs to make accurate inferences even in the presence of extremely noisy measurements since each neighboring measurement can provide accumulating evidence for a prediction. HMMs have been adapted to lineage trees (tHMMs) so that each measurement across the tree can provide accumulating evidence for a prediction. Just like with time-series data, these models can provide very accurate predictions despite noisy measurements and limited information by recognizing the co-dependence between measurements.<span class="citation" data-cites="NpTWgmsV 166ppCqyp"><sup><a href="#ref-NpTWgmsV" role="doc-biblioref">22</a>,<a href="#ref-166ppCqyp" role="doc-biblioref">23</a></sup></span> tHMMs have been used in a multitude of applications, from image classification to comparative genomics.<span class="citation" data-cites="CtsvFuNR DwaDMIcb"><sup><a href="#ref-CtsvFuNR" role="doc-biblioref">24</a>,<a href="#ref-DwaDMIcb" role="doc-biblioref">25</a></sup></span> In cells, these models have been fit to lineages collected from stem cells and bacteria colonies.<span class="citation" data-cites="ekdPNhEM 1BIrh4wZS"><sup><a href="#ref-ekdPNhEM" role="doc-biblioref">26</a>,<a href="#ref-1BIrh4wZS" role="doc-biblioref">27</a></sup></span> Improvements in cell tracking and high-throughput imaging promise to make these models valuable techniques for studying the plasticity of heterogeneous cell populations. However, widespread use will require usable implementations that can be readily adapted to different experimental measurements, examples of unique insights they can provide, and standards for experimental validation.</p>
<!-- Introduction to the paper -->
<p>Here, we develop a generic implementation of tHMMs with a defined interface for integrating diverse types of measurements on binary or cell lineage trees. We use this to analyze how populations of single breast cancer cells respond to therapy with a cell cycle reporter. Single-cell measurements of the cell cycle revealed extensive variation in drug response that is not captured in population-level measurement. This model allows us to quantify the dynamics and phenotypic features of heterogeneity in drug response. Furthermore, we are able to predict the most likely number of phenotypically distinct subpopulation, cell state distribution, transition probabilities from one state to another, and each cell’s expected state. This work, therefore, provides a flexible phenotype-driven route to discovering cell-to-cell variation in drug response, demonstrates an overall strategy for quantifying the dynamics of cell heterogeneity, and implements a very general software tool for widespread use of tHMM models.</p>
<h2 id="results">Results</h2>
<h3 id="lineage-information-provides-unique-information-about-the-source-and-dynamics-of-heterogeneity">Lineage information provides unique information about the source and dynamics of heterogeneity</h3>
<p>To illustrate the unique value of lineage measurements when analyzing heterogeneous drug responses, we plotted a series of lineages from our measurements of the breast cancer cell line AU565 treated with gemcitabine (Fig. <a href="#fig:lineage">1</a>). While there is a striking difference in the growth dynamics of individual cells, the total number of cells at any given time is nearly identical. As a result, population-level drug response measurements cannot distinguish these differences (CITE). Measurements that record the history of cells (e.g., CFSE staining, Luria-Delbruck experiment) can help to distinguish these two populations but must make assumptions about the dynamics of heterogeneity.<span class="citation" data-cites="1EqKfJscv OwA4M4C"><sup><a href="#ref-1EqKfJscv" role="doc-biblioref">21</a>,<a href="#ref-OwA4M4C" role="doc-biblioref">28</a></sup></span> Lineage measurements, by contrast, provide sufficiently rich measurements to quantify the specific structure of heterogeneous response. By observing individual cells, a variety of phenotypic measurements such as inter-mitotic times, cell cycle phase durations, motility, cell death and division, morphology, and protein and transcription factor levels can be characterized in parallel (CITE).</p>
<div id="fig:lineage" class="fignos">
<figure>
<img src="figure1.svg" alt="" /><figcaption><span>Figure 1:</span> <strong>Population-based measurements are insufficient to distinguish the structure of heterogeneous populations.</strong> Lineages of AU565 cells (a) untreated or (b) treated with 5 nM gemcitabine. Each line indicates the lifetime of one cell. The line branching into two lines indicates cell division. Both conditions have the same initial and final number of cells. However, the contribution of individual cells to population growth is clearly different.</figcaption>
</figure>
</div>
<h3 id="a-lineage-tree-based-hidden-markov-model-infers-the-state-of-cells-given-measurements-on-lineage-trees">A lineage tree-based hidden Markov model infers the state of cells given measurements on lineage trees</h3>
<p>Given the unique insights that single-cell measurements on lineage trees can provide, we wished to implement a strategy for classifying cells based on their phenotype and relationships. Given a set of measurements made across a lineage tree, we used a lineage tree-based hidden Markov model (tHMM) to fit these data (Fig. <a href="#fig:tree">2</a>a). Like a typical hidden Markov model, a tHMM can infer the hidden discrete states of cells given a series of measurements. This takes place using an iterative strategy wherein the states of each cell are predicted given their phenotype and relatives (“expectation” step), and then each distribution of phenotypes is fit to match the cells within that state (“maximization” step) (Fig. <a href="#fig:tree">2</a>b). This expectation-maximization (EM) process repeats until convergence.</p>
<p>After fitting, the model can provide a variety of information (Fig. <a href="#fig:tree">2</a>c). First, it estimates the starting abundance of each state and the transition probabilities between them. Second, the phenotypes of cells in each state are estimated and can be compared to distinguish how cells of each state behave. The state of each cell can be predicted from the fit data or new measurements. Finally, the model provides a likelihood of each cell’s observations and therefore the data overall. This last quantity can be used, for example, to estimate the number of distinguishable cell states. When implementing these processes, we ensured that a cell’s measurements are defined through a modular interface, allowing other forms of data to be easily integrated.</p>
<div id="fig:tree" class="fignos">
<figure>
<img src="figure2.svg" alt="" /><figcaption><span>Figure 2:</span> <strong>The tHMM interface.</strong> (a) Input data takes the form of single-cell measurements, where the lineage relationship between cells is known. (b) The fitting process includes expectation and maximization steps, where model parameters are iteratively updated until convergence. (c) Output predictions of the model after fitting including the tree of inferred cell states, probabilities of transition between each state, starting abundance of each cell state, and distributions that describe the behavior of cells within each state. The model likelihood can be used to estimate the number of distinguishable cell states.</figcaption>
</figure>
</div>
<h3 id="experiments-of-finite-time-necessitate-experimental-censorship-corrections">Experiments of finite time necessitate experimental censorship corrections</h3>
<p>Modeling cell growth and therefore the duration of each cell’s lifetime is complicated by the influence of experimental factors. Specifically, cells at the beginning or end of an experiment persist beyond its duration and so, while we observe them, we do not know the duration of their cell cycle phases. Previously, this has been addressed by simply removing incompletely-observed cells.<span class="citation" data-cites="1G0sgJjjW"><sup><a href="#ref-1G0sgJjjW" role="doc-biblioref">29</a></sup></span> However, doing so results in a systematic bias, where longer-lived cells are preferentially eliminated. On the other hand, treating these truncated values like they were not truncated also creates a systematic bias; for example, the experiment duration would become an upper bound on the cells’ lifetimes.</p>
<p>To incorporate this effect into our model, we marked cells or their specific cell cycle phase that encountered the bounds of the experiment as such. When estimating the properties of a cell’s lifetime or the probability of a cell’s observation, these cells instead used a censored estimator or the survival function of the distribution (CITE). Using synthetic data, we verified that this correction resulted in accurate phenotype estimations (Fig. <a href="#fig:censor">3</a>). As exhibited, using the censored estimator as opposed to the uncensored model on incompletely-observed cells results in higher cell state assignment accuracy. Thus, taking into account the cells that outlive the bounds of the experiment through a censored model ensures that we can accurately infer cell states despite the contribution of experiment duration.</p>
<div id="fig:censor" class="fignos">
<figure>
<img src="figure4.svg" alt="" /><figcaption><span>Figure 3:</span> <strong>Experiments of finite time necessitate data censorship corrections.</strong> (a) An example, randomly-generated, uncensored two-state lineage. (b) An example, randomly-generated, censored two-state lineage. State 0 and 1 cells are shown in different colors. (c) State assignment accuracy with censored lineages using an uncensored model. (d) State assignment accuracy with experiment time- and cell death-censored lineages. Each scatter point represents the state assignment accuracy of a lineage with the shown cell number that has been fitted to the model.</figcaption>
</figure>
</div>
<h3 id="synthetic-lineage-benchmarks-show-a-thmm-can-accurately-estimate-population-behavior">Synthetic lineage benchmarks show a tHMM can accurately estimate population behavior</h3>
<p>To evaluate how accurately a tHMM model could infer the behavior of multi-state cell populations, we used synthetic populations of cells in a wide variety of configurations. In each case, we determined that our implementation of a tHMM model could accurately infer the hidden states and parameters of a population given roughly 100 cells. This synthetic data included situations that were both not censored (Figs. <a href="#fig:uncenSingle">S1</a>, <a href="#fig:uncenMulti">S2</a>, <a href="#fig:performUncenSingle">S8</a>, <a href="#fig:performUncenMulti">S9</a>) and censored due to cell death and experimental duration to be a valid representative of experimental lineages (Figs. <a href="#fig:performSyn">4</a>, <a href="#fig:performCenMulti">S10</a>, <a href="#fig:cenMulti">S3</a>). In addition to varying the number of cells in a population, we benchmarked populations with varied cell state percentages (Figs. <a href="#fig:prop4">S4</a>, <a href="#fig:real_5">S5</a>) and varied degrees of phenotypic differences (Figs. <a href="#fig:wass1">S6</a>, <a href="#fig:wass2">S7</a>, <a href="#fig:wass">5</a>). In total, this benchmarking showed that our tHMM model would provide accurate results across a range of circumstances.</p>
<p>More specifically, one of the benchmarking studies we performed was with data matching our measurements of AU565, where G1 and S/G2 phase periods were quantified (Fig. <a href="#fig:performSyn">4</a>a). Although the tHMM model was fit with no information about the true underlying parameters of the simulated cells, it accurately distinguished the two underlying cell states’ phenotypes (Fig. <a href="#fig:performSyn">4</a>b–d) and member cells (Fig. <a href="#fig:performSyn">4</a>e). On the population level, the transition and starting probabilities were accurately estimated (Fig. <a href="#fig:performSyn">4</a>f–g). Thus, we are confident that, with similar experimental data, we should derive accurate results.</p>
<div id="fig:performSyn" class="fignos">
<figure>
<img src="figure5.svg" alt="" /><figcaption><span>Figure 4:</span> <strong>Model performance on censored lineages of increasing breadth and depth.</strong> (a) Two-state populations of increasing breadth (increasing number of initial cells and therefore lineages) and of increasing depth (increasing experiment time) are analyzed. The states are shown in green and blue colors and red shows cell death. The model performance is shown based on (b) state assignment accuracy, (c) the error between the estimated and the true transition rate matrix and the (d) initial probability vector. Note that the Wasserstein distance between the true and estimated distributions for each state is much lower than the distance for two distributions that are quite similar (Fig. <a href="#fig:wass">5</a>b). In (e-f) it shows the accuracy in estimating the Bernoulli parameters for G1 and S/G2 phase, respectively, and (g) depicts the distance between the true and estimated Gamma distributions associated with phase lengths for the two states. Each point in the scatter plots represents the estimated value for a lineage with the number of cells shown in the x-axis. The solid lines are the linear regressions for the scatter points.</figcaption>
</figure>
</div>
<h3 id="lineage-information-improves-cell-state-identification-for-heritable-phenotypes">Lineage information improves cell state identification for heritable phenotypes</h3>
<p>Cells of even very distinct molecular states can have partly overlapping phenotypes due to non-heritable variation. Therefore, we sought to evaluate how different two states would need to be for us to accurately identify them as distinct (Fig. <a href="#fig:wass">5</a>a). We varied the G1 phase duration of two states from identical to very distinct (Fig. <a href="#fig:wass">5</a>b) and quantified the accuracy of our model. While the phenotypic observation of a given state had to be different for our model to accurately assign cells, even partly overlapping phenotypes could be distinguished by using the lineage relationships of cells (Fig. <a href="#fig:wass">5</a>c). As a baseline comparison, we used K-means clustering to cluster cells based on their phenotype without using their lineage relationships (Fig. <a href="#fig:wass">5</a>c). A tHMM consistently out-performed this approach. The model performance in censored and uncensored populations were similar (Fig. <a href="#fig:wass1">S6</a>, <a href="#fig:wass2">S7</a>). This shows that the heritability of a cell state can help to more accurately identify cells with partially overlapping phenotypes.</p>
<div id="fig:wass" class="fignos">
<figure>
<img src="figure6.svg" alt="" /><figcaption><span>Figure 5:</span> <strong>Model performance versus the Wasserstein distance between states.</strong> (a) Cartoon of how two states can vary in their phenotypic similarity. On the left, cells might be virtually indistinguishable (here based on shape). On the right, they might be so different that looking at one cell is sufficient to identify its state. (b) The distribution of G1 duration is varied in state 1 (blue) while the other state is kept constant. (c) State assignment accuracy versus the Wasserstein distance between state phenotypes. Each point represents the accuracy of state assignment for a lineage created by a set of parameters that yield the shown Wasserstein distance between the two state distributions. Either a k-means model was used with the phenotypes of each individual cell (orange) or the full tHMM model was applied (blue). The solid lines show a Lowess trendline of the model accuracy.</figcaption>
</figure>
</div>
<h3 id="likelihood-based-model-selection-can-effectively-identify-the-number-of-distinct-states">Likelihood-based model selection can effectively identify the number of distinct states</h3>
<p>One does not usually know the number of distinct cell states within a population. Further, the number of distinct states may depend on the environmental context of the cells, particularly because we use phenotypic measurements (CITE). To test whether we could infer the number of phenotypically-distinct states, we performed model selection using the Akaike information criterion (AIC) while varying the number of states (Fig. <a href="#fig:sAIC">6</a>). The predicted number of cell states was predominantly correct, and incorrect predictions still centered around the true answer, for both uncensored and censored lineages (Fig. <a href="#fig:sAIC">6</a>). This indicated that model selection can help to identify the appropriate number of cell states for a given set of measurements.</p>
<div id="fig:sAIC" class="fignos">
<figure>
<img src="figure8.svg" alt="" /><figcaption><span>Figure 6:</span> <strong>Model selection effectively identifies the number of distinct states.</strong> (a)-(d) Model AIC for uncensored lineages with 1–4 states. (e)-(h) Model AIC for censored lineages with 1–4 states. AIC values are normalized such that the optimum is equal to 0. Histograms are shown for the minimal AIC over 10 repeated analyses.</figcaption>
</figure>
</div>
<h3 id="thmm-infers-multiple-distinct-subpopulations-in-experimental-drug-response-data">tHMM infers multiple distinct subpopulations in experimental drug response data</h3>
<p>We used phenotypic measurements of the G1 and S/G2 phase durations and fates in AU565 cells upon gemcitabine and lapatinib treatment as an application of our model. Cells were imaged every 30 minutes for 96 hours and then tracked over time to assemble their lineage relationships. First, we determined the number of distinct states the model inferred within these populations.The model was fit to the drug treatment data across all conditions, holding the initial and transition probabilities constant across concentration but allowing the phenotype emissions to independently vary in each condition. Using the Akeike information criterion as a model selection metric, the tHMM model inferred different numbers of distinct states for each drug (Fig. <a href="#fig:expAIC">7</a>a-b).</p>
<div id="fig:expAIC" class="fignos">
<figure>
<img src="figure9.svg" alt="" /><figcaption><span>Figure 7:</span> <strong>AIC-based model selection infers the likely number of phenotypically distinct subpopulations.</strong> Normalized AIC values for lapatinib- (a) and gemcitabine-treated (b) cells. For both drugs the AIC metric was subtracted by the minimum value observed so that the most likely number of distinct states has an AIC metric equal to 0.</figcaption>
</figure>
</div>
<h3 id="thmm-infers-fairly-stable-subpopulations-for-lapatinib-treated-data">tHMM infers fairly stable subpopulations for lapatinib-treated data</h3>
<p>To visualize the properties of the states that the model has identified, we plotted the distribution of average phase-specific time duration for each state and each condition. Figs. <a href="#fig:emissionsLPT">8</a>a-d accompanied with the transition probability plot (Fig. <a href="#fig:emissionsLPT">8</a>i) show that treatment with lapatinib leads to three fairly stable states. As expected, lapatinib mostly influences G1 phase where it extend the duration of this phase in all states (Fig. <a href="#fig:emissionsLPT">8</a>e) and leaves G2 progression rates almost unchanged (Fig. <a href="#fig:emissionsLPT">8</a>f). This fact could be also observed in Figs. <a href="#fig:emissionsLPT">8</a>a-d where green scatters that show cells in G1 phase, cover a wider range and could be as long as 120 hours and more, but G2 phase lengths are mosly condensed centered at ~30-50 hours long. Figs. <a href="#fig:emissionsLPT">8</a>g-h show that mostly G1 cell death happens in state 2 and 3, but death in G2 phase is observed as well, in state 1.</p>
<div id="fig:emissionsLPT" class="fignos">
<figure>
<img src="figure11.svg" alt="" /><figcaption><span>Figure 8:</span> <strong>State-specific emissions of the lapatinib-treated data.</strong> (a-d) Distribution of phase lengths for each state and for each condition in lapatinib-treated cells (control, 25 nM, 50 nM, and 250 nM). Increasing the concentration of lapatinib results in more extension of G1 phase of cells, shown in green scatter points. (e-f) G1 and G2 phase progression rates for different concentrations. Most effects of lapatinib treatment is observed in G1 phase. (g-h) G1 and G2 division probabilities for different concentration. (i) State transition graph showing the probability of state transitions among the three predicted states. Arrows and the corresponding number on top of it shows the transition probability between the two states.</figcaption>
</figure>
</div>
<h3 id="gemcitabine-treatment-leaves-stable-and-cycle-states-in-the-cell-population">Gemcitabine treatment leaves stable and cycle states in the cell population</h3>
<p>Increasing the concentration in gemcitabine-treated trials shows a trend of extension and cell death in both phases, especially in G2 (Figs. <a href="#fig:emissionsGMC">9</a>a-d). Figs. <a href="#fig:emissionsGMC">9</a>e-f show that phase progression in G1 is only evident when the concentration is very high, but cells in all three states have a decline in their G2 progression rate for every concentration. Division probability is shown in Figs. <a href="#fig:emissionsGMC">9</a>g-h where we see G1 cell death more significantly in state 1, and G2 cell death in state 2 and 3. From the transition graph (Fig. <a href="#fig:emissionsGMC">9</a>i) states 2 and 3 form a cycle while state 1 is fairly stable. Cells in state 1 seem to be slower in G1 progression in any concentration, and have higher G1 cell death probability in the highest concentration. On the other hand, although cells in state 3 have higher probability of cell in G2, but due to the high inward transition probability from state 2, they are not depleted in G2.</p>
<div id="fig:emissionsGMC" class="fignos">
<figure>
<img src="figure12.svg" alt="" /><figcaption><span>Figure 9:</span> <strong>State-specific emissions of the gemcitabine-treated data.</strong> (a-d) Distribution of phase lengths for each state and for each condition in gemcitabine-treated cells (control, 5 nM, 10 nM, and 30 nM). (e-f) G1 and G2 progression rates for different concentrations. Cells in state 1 have the highest G1 arrest rate. (g-h) G1 and G2 division probabilities for different concentration. (i) Transition graph showing the probability of state transition between the 3 predicted states within the cells.</figcaption>
</figure>
</div>
<h2 id="discussion">Discussion</h2>
<p>The model classified all types of synthetic populations of 2 true states with the accuracy higher than 90% for a minimum of ~50 cells in the population. In the cases with fewer number of observation types the accuracy reached almost 100%, however, slightly less accurate with phase-specific observations. The model showed relatively high sensitivity to the populations with under-represented sub-populations and proved efficacious with more distinct state features. Particularly in comparison to K-means clustering algorithm, the average accuracy of state assignment was higher by <span class="math inline">\(15%\)</span>. Missing information in the form of time censorship did adversely affect the performance, however, we were able to handle the influence to be minimum. The model selection validated by AIC metric asserted the reliability of tHMM in predicting the most likely number of states within a population.</p>
<p>There are some lineages, however, on which the tHMM performed poorly, in particular lineages with less than 5 cells when they are evaluated for more than 3 states. Also, the model is dependent on the distance between the existing states and may perform poorly when the states are close or when the susceptible cells possessed high variance in parameter estimation. The deviations are also seen in the resistant cells, as some of the exponential estimates were orders of magnitude higher than the true value. The Gamma estimator, similar to any other lifetime distribution, suffered from survivorship bias due to removal of unfinished cells that were still alive at the end of the tracking period. Specifically, cells with longer lifetimes (i.e. higher growth rate) are more likely to live beyond the tracking period. We separated the censored and fully observed values and handled the censored values using a survival function. This unavoidable phenomenon, if not properly handled, could lead to the growth rate parameter approaching a value less than the true value and biased estimation. Although Bernoulli estimations are centered around their respective true values, they suffer from survivorship bias as well because cells with higher Bernoulli parameter divide more often and thus have a higher sample size for prediction. This leads to the resistant cell line possessing more accurate Bernoulli estimations relative to the susceptible subpopulation.</p>
<p>The tHMM accuracy performs maximum likelihood estimation using cell observations from each lineage in the population. Thus, the improved performance accuracy and decrease in its variance as lineage number increases validates the model architecture. Parameter estimation and initial and transition probability matrix estimations were accurate in most cases of synthetic data and the tHMM was able to better distinguish the separate subpopulations as more lineages were added. Furthermore, the model operates equally well whether the population of interest owns a pre-existing phenotypic heterogeneity or the cells acquire diverse phenotypes as a result of drug treatment.</p>
<p>In this work, we present a machine learning pipeline, the tHMM, that can analyze tree-structured data using any measurements from the parent and daughter nodes. In particular, we apply our algorithm to a cell imaging protocol that inputs cell fate and G1 and S/G2 phase lengths into the tHMM pipeline and can be used with time-lapsed images for real-time classification. The tHMM is able to construct and analyze cell lineage trees to properly assign cells to different states based on virtually any number of phenotypic properties of cell fitness (in the case of our data, three), and also quantify the likelihood of transitioning to a different state using emissions and the transition rate matrix. Utilizing the AIC metric, the model predicted 3 and 4 distinct subpopulations for lapatinib and gemcitabine-treated data, respectively. We are designing assays to experimentally validate the number of states predicted by tHMM. The current version of this pipeline is most accurate when populations consist of at least 50 cells per lineage. Cell transitions from therapy-susceptible to therapy-resistant states are well detected by the model, which will prove useful for identifying mutant subtypes in tumors and leading to more optimal therapies for cancer treatment. The tHMM may further be used for drug screening as a single-cell, rather than population-based, means of quantifying the potency of novel therapies in eliminating all subpopulations within a tumor. The pipeline will provide researchers and clinicians with an improved classification of heterogeneity among cells, or any other tree-structured data, and provide information about latent changes in cellular identity.</p>
<h2 id="materials-and-methods">Materials and Methods</h2>
<h3 id="lineage-tree-based-hidden-markov-model">Lineage tree-based hidden Markov model</h3>
<p>The core assumption of a Markov chain is that the next state and current observation are only dependent on the current state. Proof of many of the expressions below can be found in Durand et al.<span class="citation" data-cites="166ppCqyp"><sup><a href="#ref-166ppCqyp" role="doc-biblioref">23</a></sup></span> The tHMM is composed of several intermediate steps to carry out predictions and estimations.</p>
<h4 id="basic-model-structure">Basic model structure</h4>
<p>The initial probabilities of a cell being in state <span class="math inline">\(k\)</span> are represented by the vector <span class="math inline">\(\pi\)</span> that sums to 1:<br />
<span class="math display">\[\pi_k = P(z_1 = k), \qquad k \in \{1, ..., K\}\]</span><br />
where <span class="math inline">\(z\)</span> shows the states and <span class="math inline">\(K\)</span> is the total number of states. The probability of state <span class="math inline">\(i\)</span> transitioning to state <span class="math inline">\(j\)</span> is represented by the <span class="math inline">\(K \times K\)</span> matrix, <span class="math inline">\(T\)</span>, in which each row sums to 1:<br />
<span class="math display">\[T_{i,j} = T(z_i \rightarrow z_j) = P(z_j \;| z_i), \qquad i,j \in \{1, ..., K\}\]</span><br />
The emission likelihood matrix, <span class="math inline">\(EL\)</span>, is based on the cell observations. It is defined as the probability of an observation conditioned on the cell being in a specific state:<br />
<span class="math display">\[EL(n,k) = P(x_n = x | z_n = k)\]</span>
where <span class="math inline">\(x_n\)</span> shows the cell number <span class="math inline">\(n\)</span>, with a total of N cells in a lineage.
Separate observations were assumed to be independent; for instance, cell fate is considered to be independent from the time duration of each cell phase. This faciliatates calculating the likelihood of observations, such that we multiply the likelihood of all observations together for the total likelihood. Since the hidden states are unobserved, we need an expectation-maximization (EM) algorithm, in this case we call it Baum-Welch algorithm, to find the states and their specifications. EM algorithm consists of two steps: (1) the expectation step (E-step) and (2) maximization step (M-step.) In the E-step, given the whole lineage tree the probability of a cell and its parent being in specific states are calculated, such that for every cell and every state we have <span class="math inline">\(P(z_n = k \;| X_n) \label{E1}\)</span> and <span class="math inline">\(P(z_n = k,\; z_{n+1} = l \; | X_n) \label{E2}\)</span>. The E-step is calculated by the upward and downward recursion algorithms.</p>
<p>In the M-step, distribution parameters of each state and hyper parameters such as the initial (<span class="math inline">\(\pi\)</span>) and transition probability (<span class="math inline">\(T\)</span>) matrices are calculated, given the estimated states of each cell. In each run, we switch between the E-step and the M-step and calculate the likelihood. If the likelihood stops improving, the process stops and exists the algorithm, which means convergence has been reached. The following explains each step in detail.</p>
<h4 id="e-step">E-step</h4>
<h5 id="upward-recursion">Upward recursion</h5>
<p>An <em>upward-downward</em> algorithm for calculating the probabilities in hidden Markov chains (HMCs) was previously proposed by Erphaim and Merhav<span class="citation" data-cites="JRNlQvSH"><sup><a href="#ref-JRNlQvSH" role="doc-biblioref">30</a></sup></span> which suffered from the underflow problem. This problem was originally solved by Levinson<span class="citation" data-cites="8YJUISJf"><sup><a href="#ref-8YJUISJf" role="doc-biblioref">31</a></sup></span> for HMCs, where they adopted a heuristic based scaling, and then was upgraded by Devijver et al.,<span class="citation" data-cites="doi:10.1016/0167-8655"><sup><span class="citeproc-not-found" data-reference-id="doi:10.1016/0167-8655"><strong>???</strong></span></sup></span> where they introduced smooth probabilities. Durand et al.,<span class="citation" data-cites="166ppCqyp"><sup><a href="#ref-166ppCqyp" role="doc-biblioref">23</a></sup></span> however, revised this approach for hidden Markov trees to avoid underflow when calculating <span class="math inline">\(P(Z|X)\)</span> probability matrices. To explain that, we need to know the following definitions:</p>
<ul>
<li><span class="math inline">\(p(n)\)</span> is noted as the parent cell of the cell <span class="math inline">\(n\)</span>, and <span class="math inline">\(c(n)\)</span> is noted as children of cell <span class="math inline">\(n\)</span>.</li>
<li><span class="math inline">\(\bar{X}\)</span> is the observation of the whole tree and <span class="math inline">\(\bar{X}_a\)</span> is a subtree of <span class="math inline">\(\bar{X}\)</span> which is rooted at cell <span class="math inline">\(a\)</span>.</li>
<li><span class="math inline">\(\bar{Z}\)</span> is the complete hidden state tree.</li>
<li><span class="math inline">\(\bar{X}_{a/b}\)</span> is the subtree rooted at <span class="math inline">\(a\)</span> except for the subtree rooted at cell <span class="math inline">\(b\)</span>, if <span class="math inline">\(\bar{X}_b\)</span> is a subtree of <span class="math inline">\(\bar{X}_a\)</span>.</li>
</ul>
<p>For the state prediction we start by calculating the marginal state distribution (MSD) matrix. MSD is an <span class="math inline">\(N \times K\)</span> matrix that for each cell is marginalizing the transition probability over all possible current states by traversing from root to leaf cells:<br />
<span class="math display">\[MSD(n,k) = P(z_{n} = k)= \sum_{i} P(z_n = k |z_{n-1} = i)\times P(z_{n-1} = i)\]</span></p>
<p>During upward recursion, the flow of upward probabilities is calculated from leaf cells to the root cells generation by generation. For leaf cells, the probabilities (<span class="math inline">\(\beta\)</span>) are calculated by:<br />
<span class="math display">\[\beta(n,k) = P(z_n = k\;|X_n = x_n) = \frac{EL(n,k) \times MSD(n,k)}{NF_l(n)}\]</span></p>
<p>in which <span class="math inline">\(X_n\)</span> is the leaf cell’s observation, and NF (Normalizing Factor) is an <span class="math inline">\(N \times 1\)</span> matrix that is the marginal observation distribution. Since <span class="math inline">\(\sum_{k} \beta_n(k) = 1\)</span>, we find the NF for leaf cells using:<br />
<span class="math display">\[NF_l(n) = \sum_{k} EL(n,k) \times MSD(n,k) = P(X_n = x_n)\]</span></p>
<p>For non-leaf cells the values are given by:<br />
<span class="math display">\[ \beta(n,k) = P(z_n = k\;|\bar{X}_n = \bar{x}_n) = \frac{EL(n,k) \times MSD(n,k) \times \prod_{v \in c(n)}\beta_{n,v}(k)}{NF_{nl}(n)}\]</span></p>
<p>where we calculate the non-leaf NF using:<br />
<span class="math display">\[NF_{nl}(n) = \sum_{k} \Big[EL(n,k) \times MSD(n,k) \prod_{v \in c(n)} \beta_{n,v}(k)\Big]\]</span></p>
<p>and linking <span class="math inline">\(\beta\)</span> between parent-daughter cells is given by:<br />
<span class="math display">\[ \beta_{p(n), n}(k) = P(\bar{X}_n = \bar{x}_n | z_{p(n)} = k) = \sum_{j} \frac{\beta_n(j) \times T_{k,j}}{MSD(n,j)}\]</span></p>
<p>By recursing from leaf to root cells, the <span class="math inline">\(\beta\)</span> and NF matrices are calculated as upward recursion. The NF matrix gives a convenient expression for the log-likelihood of the observations. For each root cell we have:</p>
<p><span class="math display">\[P(\bar{X} = \bar{x}) = \prod_{n} \frac{P(\bar{X}_n = \bar{x}_n)}{\prod_{v\in c(n)} P(\bar{X}_v = \bar{x}_v)} = \sum_{n} NF(n) \qquad n \in \{1, ..., N\}\]</span></p>
<p>The overall model log-likelihood is given by the sum over root cells:</p>
<p><span class="math display">\[log P(\bar{X} = \bar{x}) = \sum_{n} log NF(n)\]</span></p>
<p>This quantity acts as the convergence measure of the EM algorithm.</p>
<h5 id="downward-recursion">Downward recursion</h5>
<p>For computing <em>downward recursion</em>, we need the following definition for each root cells:</p>
<p><span class="math display">\[ \gamma_1(k) = P(z_1 = k | \bar{X}_1 = \bar{x}_1) = \beta_1(k)\]</span></p>
<p>The other cells follow in an <span class="math inline">\(N \times K\)</span> matrix by writing the conditional probabilities as the summation over the joint probabilities of parent-daughter cells:</p>
<p><span class="math display">\[\gamma_n(k) = P(z_n = k | \bar{X}_1 = \bar{x}_1) = \frac{\beta_n(k)}{MSD(n,k)} \sum_{i}\frac{T_{i,k} \gamma_{p(n)}(i)}{\beta_{p(n),n}(i)}\]</span></p>
<h5 id="viterbi-algorithm">Viterbi algorithm</h5>
<p>Given a sequence of observations in a hidden Markov chain, the Viterbi algorithm is commonly used to find the most likely sequence of states. Equivalently, here it returns the most likely sequence of states of the cells in a lineage tree using upward and downward recursion.<span class="citation" data-cites="166ppCqyp"><sup><a href="#ref-166ppCqyp" role="doc-biblioref">23</a></sup></span></p>
<p>Viterbi follows an upward recursion from leaf to root cells. We define <span class="math inline">\(\delta\)</span>, an <span class="math inline">\(N \times K\)</span> matrix:</p>
<p><span class="math display">\[\delta (n,k) = \max\limits_{\bar{z}_{c(n)}}\{P(\bar{X}_n = \bar{x}_n, \bar{Z}_{c(n)} = \bar{z}_{c(n)} | z_n = j)\}\]</span></p>
<p>and the links between parent-daughter cells as:</p>
<p><span class="math display">\[\delta_{p(n),n}(k) = \max\limits_{\bar{z}_n} \{P(\bar{X}_n = \bar{x}_n, \bar{Z}_n = \bar{z}_n | z_{p(n)} = j)\} = \max\limits_{j}\{\delta(n,j) T_{k,j}\}\]</span></p>
<p>We initialize from the leaf cells as:</p>
<p><span class="math display">\[\delta(n,k) = P(X_n = x_n | z_n = k) = EL(n,k)\]</span></p>
<p>and for non-leaf cells use:</p>
<p><span class="math display">\[\delta(n,k) = \Big[\prod_{v \in c(n)} \delta_{n,v}(k)\Big]\times EL(n,k)\]</span></p>
<p>The probability of the optimal state tree corresponding to the observations tree, assuming root cell is noted as cell 1, is given by:</p>
<p><span class="math display">\[Z^* = \max\limits_{k}\{\delta(1,k) \pi_k \}\]</span></p>
<p>which arises from maximization over the conditional emission likelihood (EL) probabilities by factoring out the root cells as the outer maximizing step over all possible states.</p>
<h4 id="m-step">M-step</h4>
<p>In the M-step, we find the maximum likelihood of the parameters corresponding to the hidden Markov model. Here, we estimate <span class="math inline">\(\theta = (\pi, T, p, a, s)\)</span> the initial and transition probability matrices, the parameters of the observation distributions, i.e., division probability from the Bernoulli distribution, and shape, and scale parameters of the Gamma distribution. We do so by maximizing the joint probability of the observations and states given the parameters from the previous step; in other words <span class="math inline">\(\theta^* = \max\limits_{\theta} P(Z, X|\theta)\)</span> where <span class="math inline">\(\theta\)</span> refers to the parameters estimated in the previous step. We define a probability <span class="math inline">\(\xi_n(j,k) = P(Z, X|\theta)\)</span>. According to Bayes theorem we can write that as <span class="math inline">\(P(Z|X,\theta) \times P(X|\theta)\)</span> and since <span class="math inline">\(P(\bar{X}_1 = \bar{x}_1\)</span> | ) is the emission likelihood probabilities of the whole tree, it is just a constant coefficient and we can ignore it. Writing $P(Z|X,) as a joint probability, we have:
<span class="math display">\[ \xi_n(j,k) = P(z_n = j, z_{p(n)} = k | \bar{X}_1 = \bar{x}_1)\]</span>
which is equivalent to:
<span class="math display">\[ \xi_n(j,k) = \frac{\beta(n+1, k) \times T_{j,k} \times \gamma_j(n)}{MSD(n+1, k) \times \beta_{p(n),n}(j)}\]</span>
The maximum likelihood estimation of the initial probabilities:<br />
<span class="math display">\[ \pi^*_k = \gamma_1(k)\]</span>
The transition probability matrix would be estimated as:<br />
<span class="math display">\[ T^*_{i,j} = \frac{\sum_{n=1}^{N-1} \xi_n(i,j)}{\sum_{n=1}^{N-1} \gamma_n(i)} \]</span></p>
<p>To estimate the distribution parameters after finding the most likely state for each cell, we group them and group their observations based on their estimated state and calculate their maximum likelihood estimation. The experimental data includes measurements of cell fate and G1 and S/G2 phase lengths for lapatinib treatement with 25 nM, 100 nM, and 250 nM and for gemcitabine treatment with 5 nM, 10 nM, and 30 nM. By fitting the lineage data of each condition we would get a set of estimated parameters for the distribution of phase lengths and fate for each cell state. For estimating the Bernoulli parameter we simply find the sample mean of the observations for each state. Assuming we have <span class="math inline">\(N_1\)</span> data points estimated in state 1, the corresponding Bernoulli parameter for state 1 would be:</p>
<p><span class="math display">\[ p^*_1 = \frac{\sum_{i=1}^{N_1} x_b(i)}{N_1}\]</span></p>
<p>And for Gamma distribution parameters we use a closed-form estimation based on  which has been corrected for bias:<br />
<span class="math display">\[ a^* = \frac{N_1 \times  \sum_{i=1}^{N_1} x_g(i)}{\Big[N_1 \times \sum_{i=1}^{N_1} x_g(i) ln(x_g(i))\Big] - \sum_{i=1}^{N_1} ln(x_g(i)) \times \sum_{i=1}^{N_1} x_g(i)} \]</span>
<span class="math display">\[ s^* = \frac{1}{N_1^2} \times \Big[N_1 \times \sum_{i=1}^{N_1} x_g(i) ln(x_g(i)) - \sum_{i=1}^{N_1} ln(x_g(i)) \times \sum_{i=1}^{N_1} x_g(i) \Big]\]</span></p>
<p>The shape and scale parameter from the gamma-distributed phase lengths are representations of the number of and the progression rate through the sub-phases, and since all the data is collected from one specific cell line, we assumed the number of sub-phases do not change from one condition to another. Hence, to look at the pattern of parameter change across different conditions, we decided to fit all the conditions simultaneously instead of one by one, to fix the shape parameter across different conditions. On the other hand, the pattern by which cells respond to a drug treatment, should be monotonic by increasing the drug concentration. For instance, we except to have a decreasing progression rate through G1 phase from control condition to 25 nM, to 100 nM, to 250 nM of lapatinib treatment. To apply this assumption, we forced the scale parameters in both phases to be in a decreasing order across different conditions when all the conditions are being fitted at once. For that, we used linear constrained fitting using “trust-constr” method in scipy.optimize package in Python.</p>
<h3 id="synthetic-lineage-data">Synthetic lineage data</h3>
<p>We generated synthetic lineage trees with <span class="math inline">\(K\)</span> discrete states and <span class="math inline">\(N\)</span> total number of cells for benchmarking. Lineages were composed of two primary data structures, the state and emissions trees. The state tree was randomly seeded with a root cell determined by the starting probabilities, then expanded by randomly sampling transitions based on the transition probability matrix. After creating the state tree with the desired number of cells, the emission tree is built upon it. Emissions were randomly sampled from the distributions for each cell’s state. Finally, the effects of the emissions were applied to the tree when necessary. If any cells died, their progeny were marked as unobserved by making their emissions NaN values. If applicable, the effects of finite-duration experiments were also applied. Cells existed outside of the experiment duration were similarly marked as unobserved, and those crossing the bounds of an experiment were marked as censored.</p>
<h3 id="experimental-single-cell-lineage-data">Experimental single-cell lineage data</h3>
<p>The data includes AU565 breast cancer cell line for control condition along with 7 concentrations of 2 types of targeted or chemotherapy compounds including lapatinib and gemcitabine. A fluorescent reporter was developed to translocate between the nucleus and cytoplasm to indicate the phase of the cells. Each cell is indicated as being in G1 or S/G2 phase according to the location of the reporter. When the reporter is located in the nucleus it means the cell is in G1 and when the reporter in the cytoplasm, the cell is passing through S/G2 phase. Each experiment lasts for 96 hours where the plates were being imaged every 30 minutes and each experiment was repeated three times. Single cells were manually tracked to collect cell fate in either phase or the amount of time it takes for each cell to pass through G1 and S/G2 phases.</p>
<h4 id="strategies-to-overcome-model-fitting-to-censored-data">Strategies to overcome model fitting to censored data</h4>
<p>In single-cell experimental data collection, the lineages are almost never fully observed, in other words, we experience missing data for cells with time or fate censorship. Those leaf cells living at the end of the collected lineage trees, which may have been in their G1 or S/G2 exactly when the experiment was finished, experience a right-censorship, meaning, we have missing data from the future. For a cell that was in G1 at the end of the experiment, the time that the cell transitions to S/G2 is unknown, hence the cell’s G1 is censored. In a similar way, almost all of the root cells appearing at the very beginning of the experiment are left-censored. This way, given a population of cells, we identify whether any of the cell’s observations are censored or not. The uncensored values are passed to the estimator while the censored values will be handled by the survivor function.
Another similar challenge is the unobserved measurements when cells die and their descendants disappear or when a leaf cell reaches the experiment end time while it is in the G1 phase such that the S/G2 phase for this cell is unobserved. We simply remove those measurements that have not been observed at all.</p>
<h3 id="model-evaluation">Model evaluation</h3>
<p>In this part we briefly mention the measures we used to quantify the model goodness-of-fit.</p>
<p>To find the most likely number of states corresponding to the observations, Akaike Information Criterion (AIC) is used.<span class="citation" data-cites="13gfM5gIA"><sup><a href="#ref-13gfM5gIA" role="doc-biblioref">32</a></sup></span> Degrees of freedom: Our model estimate a <span class="math inline">\(k \times 1\)</span> initial probability matrix, a <span class="math inline">\(k \times k\)</span> transition matrix, and a <span class="math inline">\(k \times m\)</span> matrix of state-wise parameters where <span class="math inline">\(k\)</span> is the number of states and <span class="math inline">\(m\)</span> is the number of parameters associated with observation distributions. For the phase-specific observation sets we have a total of 6 parameters including 2 Bernoulli parameters and 2 pairs of shape and scale parameters for Gamma distribution. Since the row-sums for transition and initial probability matrices must be 1, these values are not independent.</p>
<p>From distribution analysis of the phase lengths, we realized the shape parameter of the Gamma distribution remains fairly constant over different conditions, while the scale parameter changes. Hence, the shape parameter is shared between the set of populations that are treated with 4 different concentrations of the same compound. In each of these conditions, will have 2.25 number of free parameters (1 Bernoulli parameter, 1 scale parameter, and 1/4 shape parameter). With these considerations, for each state the number of free parameters while phase-specific observations will be 4.5. Ultimately, the degrees of freedom will be $k (k - 1) + (k - 1) + k * 4.5 $.</p>
<p>The Wasserstein or Kantorovich–Rubinstein metric is a measure of distance between two distributions. This metric was used to determine the difference between state emissions.<span class="citation" data-cites="4k5b0QER"><sup><a href="#ref-4k5b0QER" role="doc-biblioref">33</a></sup></span> An analytical solution, the absolute value of the difference in distribution means, was used for the Gamma distribution.</p>
<h3 id="model-benchmarking">Model benchmarking</h3>
<p>In this model, we use multivariate emission distributions to represent the physical characteristics of the cells within the lineages. To create our synthetic data we considered two possible options as our set of observations throughout an experiment. First, cell fate and cell lifetime, and second, phase-specific fate and time duration, for which we used Bernoulli and Gamma distributions. For the consistency of our model, we set a specific set of parameters for those mentioned distributions in each case. The following is the collection of distribution parameters for two-state synthetic data.</p>
<h4 id="phase-non-specific-observations">Phase non-specific observations</h4>
<p>The parameters are reflective of fitting the model to data of 5 nM lapatinib treatment. Figures <a href="#fig:prop4">S4</a>, <a href="#fig:real_5">S5</a>, <a href="#fig:performUncenSingle">S8</a>, <a href="#fig:performUncenMulti">S9</a>, and <a href="#fig:performCenMulti">S10</a> are based on these parameters.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">State</th>
<th style="text-align: center;">Bern p</th>
<th style="text-align: center;">Shape</th>
<th style="text-align: center;">Scale</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">State 1</td>
<td style="text-align: center;">0.99</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="even">
<td style="text-align: center;">State 2</td>
<td style="text-align: center;">0.75</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<h4 id="phase-specific-observations">Phase-specific observations</h4>
<p>The data in Figures <a href="#fig:censor">3</a>, <a href="#fig:performSyn">4</a>, <a href="#fig:uncenSingle">S1</a>, <a href="#fig:uncenMulti">S2</a>, and <a href="#fig:cenMulti">S3</a> was created based on the following parameters. These parameters are based on estimations from AU565 cells treated with 5 nM lapatinib.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">State</th>
<th style="text-align: center;">Bern <span class="math inline">\(G_1\)</span></th>
<th style="text-align: center;">Bern <span class="math inline">\(G_2\)</span></th>
<th style="text-align: center;">Shape <span class="math inline">\(G_1\)</span></th>
<th style="text-align: center;">Scale <span class="math inline">\(G_1\)</span></th>
<th style="text-align: center;">Shape <span class="math inline">\(G_2\)</span></th>
<th style="text-align: center;">Scale <span class="math inline">\(G_2\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">State 1</td>
<td style="text-align: center;">0.99</td>
<td style="text-align: center;">0.95</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">State 2</td>
<td style="text-align: center;">0.95</td>
<td style="text-align: center;">0.9</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<h4 id="distant-emissions">Distant emissions</h4>
<p>To create synthetic data with subpopulations of varying dissimilarity (Fig. <a href="#fig:wass">5</a>), we use the phase-specific parameters set except that the values for the G1 phase Gamma shape parameter for state 1 is varied between <span class="math inline">\([4, 12]\)</span>. This results in an increase in the Wasserstein distance between the two cell states, allowing us to measure state assignment accuracy for different dissimilarity amounts between the two states. Likewise, for Figures <a href="#fig:wass1">S6</a> and <a href="#fig:wass2">S7</a>, we simulated the overall cell lifetime duration and varied the Gamma distribution scale parameter from 1 to 8 for state 1.</p>
<h4 id="emissions-for-aic-figures">Emissions for AIC figures</h4>
<p>Figure <a href="#fig:sAIC">6</a> uses a unique set of values for the emissions matrix in order to simulate varying states for the AIC calculation.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">State</th>
<th style="text-align: center;">Bern <span class="math inline">\(G_1\)</span></th>
<th style="text-align: center;">Bern <span class="math inline">\(G_2\)</span></th>
<th style="text-align: center;">Shape <span class="math inline">\(G_1\)</span></th>
<th style="text-align: center;">Scale <span class="math inline">\(G_1\)</span></th>
<th style="text-align: center;">Shape <span class="math inline">\(G_2\)</span></th>
<th style="text-align: center;">Scale <span class="math inline">\(G_2\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">State 1</td>
<td style="text-align: center;">0.99</td>
<td style="text-align: center;">0.9</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">State 2</td>
<td style="text-align: center;">0.9</td>
<td style="text-align: center;">0.9</td>
<td style="text-align: center;">20</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">20</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">State 3</td>
<td style="text-align: center;">0.85</td>
<td style="text-align: center;">0.9</td>
<td style="text-align: center;">30</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">30</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">State 4</td>
<td style="text-align: center;">0.8</td>
<td style="text-align: center;">0.9</td>
<td style="text-align: center;">40</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">40</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>This work was supported by U01-CA215709 to A.S.M. <strong>Competing financial interests:</strong> The authors declare no competing financial interests.</p>
<h2 id="author-contributions-statement">Author contributions statement</h2>
<p>A.S.M. and L.M.H. conceived of the study; A.S.M. conceived of the model; A.S.M, F.M., S.V. designed model; A.S.M., F.M., J.L., L.K., S.V. performed computational experiments; S.M.G. performed the experiments; F.M., J.L., L.K., S.M.G. conducted data analysis; A.S.M. and L.M.H. supervised the research; all authors wrote the paper.</p>
<h2 class="page_break_before" id="supplementary-figures">Supplementary Figures</h2>
<h3 id="performance-on-an-uncensored-single-lineage-of-increasing-size">Performance on an uncensored single lineage of increasing size</h3>
<div id="fig:uncenSingle" class="fignos">
<figure>
<img src="figureS01.svg" data-tag="S1" alt="" /><figcaption><span>Figure S1:</span> <strong>Performance on an uncensored single lineages of increasing size.</strong> (a) Visual representation of cells increasing lineage size with varying states. (b) The Bernoulli parameter for states 1 and 2 as the number of cells increase. (c)-(d) The cell duration Gamma distribution shape, k, and scale, θ, for states 1 and 2 as the number of cells increase. (e) The state assignment accuracy as the number of cells increase. (f) The error in the estimate of the transition probability matrix, T as the number of cells increase.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="performance-on-uncensored-lineages-of-increasing-number">Performance on uncensored lineages of increasing number</h3>
<div id="fig:uncenMulti" class="fignos">
<figure>
<img src="figureS02.svg" data-tag="S2" alt="" /><figcaption><span>Figure S2:</span> <strong>Performance on uncensored lineages of increasing number.</strong> (a) Visualization of cells increasing in size and number of lineages. (b) The Bernoulli parameter for states 1 and 2 as the number of cells increase. (c)-(d) The cell duration Gamma distribution shape, k, and scale, θ, for states 1 and 2 as the number of cells increase. (e) The state assignment accuracy as the number of cells increase. (f) The error in the estimate of the transition probability matrix, T, as the number of cells increase. (g) The errors in the estimate of the initial probability matrix, π, as the number of cells increase.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="performance-on-censored-lineages-of-increasing-size">Performance on censored lineages of increasing size</h3>
<div id="fig:cenMulti" class="fignos">
<figure>
<img src="figureS03.svg" data-tag="S3" alt="" /><figcaption><span>Figure S3:</span> <strong>Performance on censored lineages of increasing size.</strong> (a) Visualization of cells increasing in size and number of censored lineages. (b) The Bernoulli parameter for states 1 and 2 as the number of cells increase. (c) The cell duration Gamma distribution shape, k, for states 1 and 2 as the number of cells increase. (d) The cell duration Gamma distribution scale, θ, for states 1 and 2 as the number of cells increase. (e) State assignment accuracy as the number of cells increase. (f) The error in the estimate of the transition probability matrix, T, as the number of cells increase. (g) The errors in the estimate of the initial probability matrix, π, as the number of cells increase.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="change-in-model-performance-when-varying-presence-of-a-state-for-an-uncensored-population">Change in model performance when varying presence of a state for an uncensored population</h3>
<div id="fig:prop4" class="fignos">
<figure>
<img src="figureS04.svg" data-tag="S4" alt="" /><figcaption><span>Figure S4:</span> <strong>Model performance relative to the presence of each state for an uncensored lineages.</strong> (a) Visualization of the distribution of cells in the lineage transitioning from state 1 to state 2. (b) The Bernoulli parameter for states 1 and 2 as the proportion of cells in state 1 increase. (c)-(d) The cell duration Gamma distribution shape, k, and scale, θ, for states 1 and 2 as the proportion of cells in state 1 increase. (e) The state assignment accuracy as the proportion of cells in state 1 increase. (f) The errors in the estimate of the transition probability matrix, T, as proportion of cells in state 1 increase.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="change-in-model-performance-when-varying-presence-of-a-state-for-censored-population">Change in model performance when varying presence of a state for censored population</h3>
<div id="fig:real_5" class="fignos">
<figure>
<img src="figureS05.svg" data-tag="S5" alt="" /><figcaption><span>Figure S5:</span> <strong>Performance on populations of censored lineages of increasing number.</strong> (a) Visualization of the proportion of cells in the censored lineage transitioning from state 1 to state 2. (b) The Bernoulli parameter for states 1 and 2 as the proportion of cells in state 1 increase. (c)-(d) The cell duration Gamma distribution shape, k, and scale, θ, for states 1 and 2 as the proportion of cells in state 1 increase. (e) The state assignment accuracy as the number of cells increase. (f) The error in the estimate of the transition probability matrix, T, as the number of cells increase.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="change-in-model-performance-when-varying-state-distribution-similarity-for-uncensored-populations">Change in model performance when varying state distribution similarity for uncensored populations</h3>
<div id="fig:wass1" class="fignos">
<figure>
<img src="figureS06.svg" data-tag="S6" alt="" /><figcaption><span>Figure S6:</span> <strong>Change in model performance when varying state distribution similarity with an uncensored population of lineages.</strong> (a) Visualization of the Wasserstein Divergence increasing as the state distribution in the lineage varies. (b) The cell decision Bernoulli parameter compared to the true values. (c) The cell duration Gamma distribution shape, k, compared to the true value. (d) The cell duration Gamma distribution scale, θ, compared to the true value. (e) The State Assignment Accuracy as the Wasserstein Divergence increases. (f) The errors in the estimate of the transition probability matrix, T, as the Wasserstein Divergence increases.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="change-in-model-performance-when-varying-state-distribution-similarity-for-censored-population">Change in model performance when varying state distribution similarity for censored population</h3>
<div id="fig:wass2" class="fignos">
<figure>
<img src="figureS07.svg" data-tag="S7" alt="" /><figcaption><span>Figure S7:</span> <strong>Change in model performance when varying state distribution similarity with censored lineages.</strong> (a) Visualization of the Wasserstein Divergence increasing as the state distribution in the censored lineage varies. (b)-(d) Bernoulli, Gamma shape, and Gamma scale parameters for states 1 and 2 as the Wasserstein Divergence increases. (e) The State Assignment Accuracy as the Wasserstein Divergence increases. (f) The error in the estimate of the transition probability matrix, T, as the Wasserstein Divergence increases.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="performance-on-uncensored-single-lineage-of-increasing-size-given-phase-specific-observations">Performance on uncensored single lineage of increasing size given phase specific observations</h3>
<div id="fig:performUncenSingle" class="fignos">
<figure>
<img src="figureS08.svg" data-tag="S8" alt="" /><figcaption><span>Figure S8:</span> <strong>Performance on uncensored single lineages of increasing size.</strong> (a) Visualization of a single lineage increasing in size. (b) The Bernoulli parameter for states 1 and 2 as the number of cells increase in the G1 phase. (c)-(d) The Gamma shape and scale parameters for states 1 and 2 as the number of cells increase in the G1 phase. (e) The Bernoulli parameter for states 1 and 2 as the number of cells increase in the G2 phase. (f) The Gamma shape parameter for states 1 and 2 as the number of cells increase in the G2 phase. (g) The Gamma scale parameter for states 1 and 2 as the number of cells increase in the G2 phase. (h) The state assignment accuracy as the number of cells increase. (i) The errors in the estimate of the transition probability matrix, T, as the number of cells increase.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="performance-on-uncensored-lineages-of-increasing-number-given-phase-specific-observations">Performance on uncensored lineages of increasing number given phase specific observations</h3>
<div id="fig:performUncenMulti" class="fignos">
<figure>
<img src="figureS09.svg" data-tag="S9" alt="" /><figcaption><span>Figure S9:</span> <strong>Performance on uncensored populations of lineages of increasing number.</strong> (a) Visualization of the number of uncensored lineages within a population increasing. (b)-(d) The Bernoulli, Gamma shape, and Gamma scale parameters for states 1 and 2 as the number of cells increase in the G1 phase. (e)-(g) The Bernoulli, Gamma shape, and Gamma scale parameters for states 1 and 2 as the number of cells increase in the G2 phase. (h) The state assignment accuracy as the number of cells increase. (i) The error in the estimate of the transition probability matrix, T, as the number of cells increase. (j) The errors in the estimate of the initial probability matrix, π, as the number of cells increase.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="performance-on-censored-multiple-lineages-of-increasing-size-given-phase-specific-observations">Performance on censored multiple lineages of increasing size given phase specific observations</h3>
<div id="fig:performCenMulti" class="fignos">
<figure>
<img src="figureS10.svg" data-tag="S10" alt="" /><figcaption><span>Figure S10:</span> <strong>Performance on censored multiple lineages of increasing size.</strong> (a) Visualization of the number of censored lineages within a population increasing. (b)-(d) The Bernoulli, Gamma shape, and Gamma scale parameters for states 1 and 2 as the number of cells increase in the G1 phase. (e)-(g) The Bernoulli, Gamma shape, and Gamma scale parameter for states 1 and 2 as the number of cells increase in the G2 phase. (h) The state assignment accuracy as the number of cells increases. (i) The error in the estimate of the transition probability matrix, T, as the number of cells increases. (j) The error in the estimate of the initial probability matrix, π, as the number of cells increase.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="single-cell-state-assignment-for-lapatinib-treatment">Single-cell state assignment for lapatinib treatment</h3>
<div id="fig:LapatinibTree" class="fignos">
<figure>
<img src="figure100.svg" data-tag="100" alt="" /><figcaption><span>Figure 100:</span> <strong>The single cell data after fitting and state assignment</strong> (a) Control condition. (b) 25 nM lapatinib treatment. (c) 50 nM lapatinib tratment. (d) 250 nM lapatinib treatment.</figcaption>
</figure>
</div>
<h3 class="page_break_before" id="single-cell-state-assignment-for-gemcitabine-treatment">Single-cell state assignment for gemcitabine treatment</h3>
<div id="fig:GemcitabineTree" class="fignos">
<figure>
<img src="figure150.svg" data-tag="150" alt="" /><figcaption><span>Figure 150:</span> <strong>The single cell data after fitting and state assignment</strong> (a) Control condition. (b) 5 nM gemcitabine treatment. (c) 10 nM gemcitabine tratment. (d) 30 nM gemcitabine treatment.</figcaption>
</figure>
</div>
<h2 class="page_break_before" id="references">References</h2>
<!-- Explicitly insert bibliography here -->
<div id="refs" class="references" role="doc-bibliography">
<div id="ref-wEXyiydz">
<p>1. Di Maio, M. <em>et al.</em> Chemotherapy-induced neutropenia and treatment efficacy in advanced non-small-cell lung cancer: a pooled analysis of three randomised trials. <em>Lancet Oncol</em> <strong>6</strong>, 669–77 (2005).</p>
</div>
<div id="ref-h29ZM4mv">
<p>2. De Roock, W. <em>et al.</em> Effects of KRAS, BRAF, NRAS, and PIK3CA mutations on the efficacy of cetuximab plus chemotherapy in chemotherapy-refractory metastatic colorectal cancer: a retrospective consortium analysis. <em>Lancet Oncol</em> <strong>11</strong>, 753–62 (2010).</p>
</div>
<div id="ref-1AGMG5i1a">
<p>3. Sharma, S. V. <em>et al.</em> A chromatin-mediated reversible drug-tolerant state in cancer cell subpopulations. <em>Cell</em> <strong>141</strong>, 69–80 (2010).</p>
</div>
<div id="ref-jHXzaoNt">
<p>4. Feinberg, A. P., Koldobskiy, M. A. &amp; Göndör, A. Epigenetic modulators, modifiers and mediators in cancer aetiology and progression. <em>Nature Reviews Genetics</em> <strong>17</strong>, 284–299 (2016).</p>
</div>
<div id="ref-79g6Efbb">
<p>5. Falkenberg, K. J. &amp; Johnstone, R. W. Histone deacetylases and their inhibitors in cancer, neurological diseases and immune disorders. <em>Nat Rev Drug Discov</em> <strong>13</strong>, 673–91 (2014).</p>
</div>
<div id="ref-8PjsI84U">
<p>6. Inde, Z. &amp; Dixon, S. J. The impact of non-genetic heterogeneity on cancer cell death. <em>Crit Rev Biochem Mol Biol</em> <strong>53</strong>, 99–114 (2017).</p>
</div>
<div id="ref-m4Kq0IiR">
<p>7. Pisco, A. O. &amp; Huang, S. Non-genetic cancer cell plasticity and therapy-induced stemness in tumour relapse: “What does not kill me strengthens me”. <em>British Journal of Cancer</em> <strong>112</strong>, 1725–1732 (2015).</p>
</div>
<div id="ref-1EmZp72ZM">
<p>8. Gerlinger, M. <em>et al.</em> Intratumor heterogeneity and branched evolution revealed by multiregion sequencing. <em>N Engl J Med</em> <strong>366</strong>, 883–892 (2012).</p>
</div>
<div id="ref-arjISkeW">
<p>9. Hormozdiari, F., Kostem, E., Kang, E. Y., Pasaniuc, B. &amp; Eskin, E. Identifying Causal Variants at Loci with Multiple Signals of Association. <em>Genetics</em> <strong>198</strong>, 497–508 (2014).</p>
</div>
<div id="ref-5liODcji">
<p>10. Alvarez, M. J. <em>et al.</em> Functional characterization of somatic mutations in cancer using network-based inference of protein activity. <em>Nat Genet</em> <strong>48</strong>, 838–47 (2016).</p>
</div>
<div id="ref-4Owum1Lv">
<p>11. Barretina, J. <em>et al.</em> The Cancer Cell Line Encyclopedia enables predictive modelling of anticancer drug sensitivity. <em>Nature</em> <strong>483</strong>, 603–7 (2012).</p>
</div>
<div id="ref-od9oxYIw">
<p>12. Gett, A. V., Sallusto, F., Lanzavecchia, A. &amp; Geginat, J. T cell fitness determined by signal strength. <em>Nature Immunology</em> <strong>4</strong>, 355–360 (2003).</p>
</div>
<div id="ref-tAijMuLh">
<p>13. Arai, T. <em>et al.</em> Tumor doubling time and prognosis in lung cancer patients: evaluation from chest films and clinical follow-up study. Japanese Lung Cancer Screening Research Group. <em>Jpn J Clin Oncol</em> <strong>24</strong>, 199–204 (1994).</p>
</div>
<div id="ref-Ys7Kc53C">
<p>14. Bourhis, J. <em>et al.</em> Potential doubling time and clinical outcome in head and neck squamous cell carcinoma treated with 70 GY in 7 weeks. <em>Int J Radiat Oncol Biol Phys</em> <strong>35</strong>, 471–6 (1996).</p>
</div>
<div id="ref-17XnDKTPF">
<p>15. Yachida, S. <em>et al.</em> Distant metastasis occurs late during the genetic evolution of pancreatic cancer. <em>Nature</em> <strong>467</strong>, 1114–7 (2010).</p>
</div>
<div id="ref-gckaWBL7">
<p>16. Huang, D. <em>et al.</em> High-Speed Live-Cell Interferometry: A New Method for Quantifying Tumor Drug Resistance and Heterogeneity. <em>Anal Chem</em> <strong>90</strong>, 3299–3306 (2018).</p>
</div>
<div id="ref-1ETBBN4au">
<p>17. Tyson, D. R., Garbett, S. P., Frick, P. L. &amp; Quaranta, V. Fractional proliferation: a method to deconvolve cell population dynamics from single-cell data. <em>Nat Methods</em> <strong>9</strong>, 923–8 (2012).</p>
</div>
<div id="ref-15TlHMr6M">
<p>18. O’Connor, J. P. B. <em>et al.</em> Imaging intratumor heterogeneity: role in therapy response, resistance, and clinical outcome. <em>Clin Cancer Res</em> <strong>21</strong>, 249–57 (2014).</p>
</div>
<div id="ref-xFOIrC99">
<p>19. Concannon, P. <em>et al.</em> Genome-wide scan for linkage to type 1 diabetes in 2,496 multiplex families from the Type 1 Diabetes Genetics Consortium. <em>Diabetes</em> <strong>58</strong>, 1018–22 (2009).</p>
</div>
<div id="ref-EhD8XBE4">
<p>20. Kuchen, E. E., Becker, N., Claudino, N. &amp; Höfer, T. Long-range memory of growth and cycle progression correlates cell cycles in lineage trees. <em>Cold Spring Harbor Laboratory</em> (2018). doi:<a href="https://doi.org/10.1101/373258">10.1101/373258</a></p>
</div>
<div id="ref-1EqKfJscv">
<p>21. Mitchell, S., Roy, K., Zangle, T. A. &amp; Hoffmann, A. Nongenetic origins of cell-to-cell variability in B lymphocyte proliferation. <em>Proceedings of the National Academy of Sciences</em> <strong>115</strong>, E2888–E2897 (2018).</p>
</div>
<div id="ref-NpTWgmsV">
<p>22. Crouse, M. S., Nowak, R. D. &amp; Baraniuk, R. G. Wavelet-based statistical signal processing using hidden Markov models. <em>IEEE Transactions on Signal Processing</em> <strong>46</strong>, 886–902 (1998).</p>
</div>
<div id="ref-166ppCqyp">
<p>23. Durand, J.-B., Goncalves, P. &amp; Guedon, Y. Computational Methods for Hidden Markov Tree Models—An Application to Wavelet Trees. <em>IEEE Transactions on Signal Processing</em> <strong>52</strong>, 2551–2560 (2004).</p>
</div>
<div id="ref-CtsvFuNR">
<p>24. Choi, H. &amp; Baraniuk, R. G. Multiscale image segmentation using wavelet-domain hidden Markov models. <em>IEEE Trans Image Process</em> <strong>10</strong>, 1309–21 (2001).</p>
</div>
<div id="ref-DwaDMIcb">
<p>25. Bykova, N. A., Favorov, A. V. &amp; Mironov, A. A. Hidden Markov models for evolution and comparative genomics analysis. <em>PLoS One</em> <strong>8</strong>, e65012 (2013).</p>
</div>
<div id="ref-ekdPNhEM">
<p>26. Olariu, V. <em>et al.</em> Modified variational Bayes EM estimation of hidden Markov tree model of cell lineages. <em>Bioinformatics</em> <strong>25</strong>, 2824–30 (2009).</p>
</div>
<div id="ref-1BIrh4wZS">
<p>27. Nakashima, S., Sughiyama, Y. &amp; Kobayashi, T. J. Lineage EM Algorithm for Inferring Latent States from Cellular Lineage Trees. <em>Cold Spring Harbor Laboratory</em> (2019). doi:<a href="https://doi.org/10.1101/488981">10.1101/488981</a></p>
</div>
<div id="ref-OwA4M4C">
<p>28. Shaffer, S. M. <em>et al.</em> Rare cell variability and drug-induced reprogramming as a mode of cancer drug resistance. <em>Nature</em> <strong>546</strong>, 431–435 (2017).</p>
</div>
<div id="ref-1G0sgJjjW">
<p>29. Kuchen, E. E., Becker, N. B., Claudino, N. &amp; Höfer, T. Hidden long-range memories of growth and cycle speed correlate cell cycles in lineage trees. <em>eLife</em> <strong>9</strong>, e51002 (2020).</p>
</div>
<div id="ref-JRNlQvSH">
<p>30. Ephraim, Y. &amp; Merhav, N. Hidden Markov processes. <em>IEEE Transactions on Information Theory</em> <strong>48</strong>, 1518–1569 (2002).</p>
</div>
<div id="ref-8YJUISJf">
<p>31. Levinson, S. E., Rabiner, L. R. &amp; Sondhi, M. M. An Introduction to the Application of the Theory of Probabilistic Functions of a Markov Process to Automatic Speech Recognition. <em>Bell System Technical Journal</em> <strong>62</strong>, 1035–1074 (1983).</p>
</div>
<div id="ref-13gfM5gIA">
<p>32. Zucchini, W. An Introduction to Model Selection. <em>Journal of Mathematical Psychology</em> <strong>44</strong>, 41–61 (2000).</p>
</div>
<div id="ref-4k5b0QER">
<p>33. Vallender, S. S. Calculation of the Wasserstein Distance Between Probability Distributions on the Line. <em>Theory of Probability &amp; Its Applications</em> <strong>18</strong>, 784–786 (1974).</p>
</div>
</div>
<!-- default theme -->

<style>
    /* import google fonts */
    @import url("https://fonts.googleapis.com/css?family=Open+Sans:400,600,700");
    @import url("https://fonts.googleapis.com/css?family=Source+Code+Pro");

    /* -------------------------------------------------- */
    /* global */
    /* -------------------------------------------------- */

    /* all elements */
    * {
        /* force sans-serif font unless specified otherwise */
        font-family: "Open Sans", "Helvetica", sans-serif;

        /* prevent text inflation on some mobile browsers */
        -webkit-text-size-adjust: none !important;
        -moz-text-size-adjust: none !important;
        -o-text-size-adjust: none !important;
        text-size-adjust: none !important;
    }

    @media only screen {
        /* "page" element */
        body {
            position: relative;
            box-sizing: border-box;
            font-size: 12pt;
            line-height: 1.5;
            max-width: 8.5in;
            margin: 20px auto;
            padding: 40px;
            border-radius: 5px;
            border: solid 1px #bdbdbd;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            background: #ffffff;
        }
    }

    /* when on screen < 8.5in wide */
    @media only screen and (max-width: 8.5in) {
        /* "page" element */
        body {
            padding: 20px;
            margin: 0;
            border-radius: 0;
            border: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05) inset;
            background: none;
        }
    }

    /* -------------------------------------------------- */
    /* headings */
    /* -------------------------------------------------- */

    /* all headings */
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
        margin: 20px 0;
        padding: 0;
        font-weight: bold;
    }

    /* biggest heading */
    h1 {
        margin: 40px 0;
        text-align: center;
    }

    /* second biggest heading */
    h2 {
        margin-top: 30px;
        padding-bottom: 5px;
        border-bottom: solid 1px #bdbdbd;
    }

    /* -------------------------------------------------- */
    /* manuscript header */
    /* -------------------------------------------------- */

    /* manuscript title */
    header > h1 {
        margin: 0;
    }

    /* manuscript title caption text (ie "automatically generated on") */
    header + p {
        text-align: center;
        margin-top: 10px;
    }

    /* -------------------------------------------------- */
    /* text elements */
    /* -------------------------------------------------- */

    /* links */
    a {
        color: #2196f3;
        overflow-wrap: break-word;
    }

    /* normal links (not empty, not button link, not syntax highlighting link) */
    a:not(:empty):not(.button):not(.sourceLine) {
        padding-left: 1px;
        padding-right: 1px;
    }

    /* superscripts and subscripts */
    sub,
    sup {
        /* prevent from affecting line height */
        line-height: 0;
    }

    /* unordered and ordered lists*/
    ul,
    ol {
        padding-left: 20px;
    }

    /* class for styling text semibold */
    .semibold {
        font-weight: 600;
    }

    /* class for styling elements horizontally left aligned */
    .left {
        display: block;
        text-align: left;
        margin-left: auto;
        margin-right: 0;
        justify-content: left;
    }

    /* class for styling elements horizontally centered */
    .center {
        display: block;
        text-align: center;
        margin-left: auto;
        margin-right: auto;
        justify-content: center;
    }

    /* class for styling elements horizontally right aligned */
    .right {
        display: block;
        text-align: right;
        margin-left: 0;
        margin-right: auto;
        justify-content: right;
    }

    /* -------------------------------------------------- */
    /* section elements */
    /* -------------------------------------------------- */

    /* horizontal divider line */
    hr {
        border: none;
        height: 1px;
        background: #bdbdbd;
    }

    /* paragraphs, horizontal dividers, figures, tables, code */
    p,
    hr,
    figure,
    table,
    pre {
        /* treat all as "paragraphs", with consistent vertical margins */
        margin-top: 20px;
        margin-bottom: 20px;
    }

    /* -------------------------------------------------- */
    /* figures */
    /* -------------------------------------------------- */

    /* figure */
    figure {
        max-width: 100%;
        margin-left: auto;
        margin-right: auto;
    }

    /* figure caption */
    figcaption {
        padding: 0;
        padding-top: 10px;
    }

    /* figure image element */
    figure img {
        max-width: 100%;
        display: block;
        margin-left: auto;
        margin-right: auto;
    }

    /* figure auto-number */
    img + figcaption > span:first-of-type {
        font-weight: bold;
        margin-right: 5px;
    }

    /* -------------------------------------------------- */
    /* tables */
    /* -------------------------------------------------- */

    /* table */
    table {
        border-collapse: collapse;
        border-spacing: 0;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
    }

    /* table cells */
    th,
    td {
        border: solid 1px #bdbdbd;
        padding: 10px;
        /* squash table if too wide for page by forcing line breaks */
        overflow-wrap: break-word;
        word-break: break-word;
    }

    /* header row and even rows */
    th,
    tr:nth-child(2n) {
        background-color: #fafafa;
    }

    /* odd rows */
    tr:nth-child(2n + 1) {
        background-color: #ffffff;
    }

    /* table caption */
    caption {
        text-align: left;
        padding: 0;
        padding-bottom: 10px;
    }

    /* table auto-number */
    table > caption > span:first-of-type,
    div.table_wrapper > table > caption > span:first-of-type {
        font-weight: bold;
        margin-right: 5px;
    }

    /* -------------------------------------------------- */
    /* code */
    /* -------------------------------------------------- */

    /* multi-line code block */
    pre {
        padding: 10px;
        background-color: #eeeeee;
        color: #000000;
        border-radius: 5px;
        break-inside: avoid;
        text-align: left;
    }

    /* inline code, ie code within normal text */
    :not(pre) > code {
        padding: 0 4px;
        background-color: #eeeeee;
        color: #000000;
        border-radius: 5px;
    }

    /* code text */
    /* apply all children, to reach syntax highlighting sub-elements */
    code,
    code * {
        /* force monospace font */
        font-family: "Source Code Pro", "Courier New", monospace;
    }

    /* -------------------------------------------------- */
    /* quotes */
    /* -------------------------------------------------- */

    /* quoted text */
    blockquote {
        margin: 0;
        padding: 0;
        border-left: 4px solid #bdbdbd;
        padding-left: 16px;
        break-inside: avoid;
    }

    /* -------------------------------------------------- */
    /* banners */
    /* -------------------------------------------------- */

    /* info banners */
    .banner {
        box-sizing: border-box;
        display: block;
        position: relative;
        width: 100%;
        margin-top: 20px;
        margin-bottom: 20px;
        padding: 20px;
        text-align: center;
    }

    /* paragraph in banner */
    .banner > p {
        margin: 0;
    }

    /* -------------------------------------------------- */
    /* highlight colors */
    /* -------------------------------------------------- */

    .white {
        background: #ffffff;
    }
    .lightgrey {
        background: #eeeeee;
    }
    .grey {
        background: #757575;
    }
    .darkgrey {
        background: #424242;
    }
    .black {
        background: #000000;
    }
    .lightred {
        background: #ffcdd2;
    }
    .lightyellow {
        background: #ffecb3;
    }
    .lightgreen {
        background: #dcedc8;
    }
    .lightblue {
        background: #e3f2fd;
    }
    .lightpurple {
        background: #f3e5f5;
    }
    .red {
        background: #f44336;
    }
    .orange {
        background: #ff9800;
    }
    .yellow {
        background: #ffeb3b;
    }
    .green {
        background: #4caf50;
    }
    .blue {
        background: #2196f3;
    }
    .purple {
        background: #9c27b0;
    }
    .white,
    .lightgrey,
    .lightred,
    .lightyellow,
    .lightgreen,
    .lightblue,
    .lightpurple,
    .orange,
    .yellow,
    .white a,
    .lightgrey a,
    .lightred a,
    .lightyellow a,
    .lightgreen a,
    .lightblue a,
    .lightpurple a,
    .orange a,
    .yellow a {
        color: #000000;
    }
    .grey,
    .darkgrey,
    .black,
    .red,
    .green,
    .blue,
    .purple,
    .grey a,
    .darkgrey a,
    .black a,
    .red a,
    .green a,
    .blue a,
    .purple a {
        color: #ffffff;
    }

    /* -------------------------------------------------- */
    /* buttons */
    /* -------------------------------------------------- */

    /* class for styling links like buttons */
    .button {
        display: inline-flex;
        justify-content: center;
        align-items: center;
        margin: 5px;
        padding: 10px 20px;
        font-size: 0.75em;
        font-weight: 600;
        text-transform: uppercase;
        text-decoration: none;
        letter-spacing: 1px;
        background: none;
        color: #2196f3;
        border: solid 1px #bdbdbd;
        border-radius: 5px;
    }

    /* buttons when hovered */
    .button:hover:not([disabled]),
    .icon_button:hover:not([disabled]) {
        cursor: pointer;
        background: #f5f5f5;
    }

    /* buttons when disabled */
    .button[disabled],
    .icon_button[disabled] {
        opacity: 0.35;
        pointer-events: none;
    }

    /* class for styling buttons containg only single icon */
    .icon_button {
        display: inline-flex;
        justify-content: center;
        align-items: center;
        text-decoration: none;
        margin: 0;
        padding: 0;
        background: none;
        border-radius: 5px;
        border: none;
        width: 20px;
        height: 20px;
        min-width: 20px;
        min-height: 20px;
    }

    /* icon button inner svg image */
    .icon_button > svg {
        height: 16px;
    }

    /* -------------------------------------------------- */
    /* icons */
    /* -------------------------------------------------- */

    /* class for styling icons inline with text */
    .inline_icon {
        height: 1em;
        position: relative;
        top: 0.125em;
    }

    /* -------------------------------------------------- */
    /* print control */
    /* -------------------------------------------------- */

    @media print {
        @page {
            /* suggested printing margin */
            margin: 0.5in;
        }

        /* document and "page" elements */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        /* "page" element */
        body {
            font-size: 11pt !important;
            line-height: 1.35;
        }

        /* all headings */
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            margin: 15px 0;
        }

        /* heading 1 */
        h1 {
            font-size: 1.75em;
        }

        /* heading 2 */
        h2 {
            font-size: 1.25em;
            margin-top: 0;
        }

        /* heading 3 */
        h3 {
            font-size: 1.10em;
        }

        /* figures and tables */
        figure, table {
            font-size: 0.85em;
        }

        /* table cells */
        th,
        td {
            padding: 5px;
        }

        /* shrink font awesome icons */
        i.fas,
        i.fab,
        i.far,
        i.fal {
            transform: scale(0.85);
        }

        /* decrease banner margins */
        .banner {
            margin-top: 15px;
            margin-bottom: 15px;
            padding: 15px;
        }

        /* class for centering an element vertically on its own page */
        .page_center {
            margin: auto;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            vertical-align: middle;
            break-before: page;
            break-after: page;
        }

        /* always insert a page break before the element */
        .page_break_before {
            break-before: page;
        }

        /* always insert a page break after the element */
        .page_break_after {
            break-after: page;
        }

        /* avoid page break before the element */
        .page_break_before_avoid {
            break-before: avoid;
        }

        /* avoid page break after the element */
        .page_break_after_avoid {
            break-after: avoid;
        }

        /* avoid page break inside the element */
        .page_break_inside_avoid {
            break-inside: avoid;
        }
    }

    /* -------------------------------------------------- */
    /* override pandoc css quirks */
    /* -------------------------------------------------- */

    .sourceCode {
        /* prevent unsightly overflow in wide code blocks */
        overflow: auto !important;
    }

    div.sourceCode {
        /* prevent background fill on top-most code block  container */
        background: none !important;
    }

    .sourceCode * {
        /* force consistent line spacing */
        line-height: 1.5 !important;
    }

    div.sourceCode {
        /* style code block margins same as <pre> element */
        margin-top: 20px;
        margin-bottom: 20px;
    }

    /* -------------------------------------------------- */
    /* tablenos */
    /* -------------------------------------------------- */

    /* tablenos wrapper */
    .tablenos {
        /* show scrollbar on tables if necessary to prevent overflow */
        width: 100%;
        margin: 20px 0;
    }

    .tablenos > table {
        /* move margins from table to table_wrapper to allow margin collapsing */
        margin: 0;
    }

    @media only screen {
        /* tablenos wrapper */
        .tablenos {
            /* show scrollbar on tables if necessary to prevent overflow */
            overflow-x: auto !important;
        }

        .tablenos th,
        .tablenos td {
            overflow-wrap: unset !important;
            word-break: unset !important;
        }

        /* table in wrapper */
        .tablenos table,
        .tablenos table * {
            /* don't break table words */
            overflow-wrap: normal !important;
        }
    }

    /* -------------------------------------------------- */
    /* mathjax */
    /* -------------------------------------------------- */

    /* mathjax containers */
    .math.display > span:not(.MathJax_Preview) {
        /* turn inline element (no dimensions) into block (allows fixed width and thus scrolling) */
        display: flex !important;
        overflow-x: auto !important;
        overflow-y: hidden !important;
        justify-content: center;
        align-items: center;
        margin: 0 !important;
    }

    /* right click menu */
    .MathJax_Menu {
        border-radius: 5px !important;
        border: solid 1px #bdbdbd !important;
        box-shadow: none !important;
    }

    /* equation auto-number */
    span[id^="eq:"] > span.math.display + span {
        font-weight: 600;
    }

    /* equation */
    span[id^="eq:"] > span.math.display > span {
        /* nudge to make room for equation auto-number and anchor */
        margin-right: 60px !important;
    }

    /* -------------------------------------------------- */
    /* anchors plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* anchor button */
        .anchor {
            opacity: 0;
            margin-left: 5px;
        }

        /* anchor buttons within <h2>'s */
        h2 .anchor {
            margin-left: 10px;
        }

        /* anchor buttons when hovered/focused and anything containing an anchor button when hovered */
        *:hover > .anchor,
        .anchor:hover,
        .anchor:focus {
            opacity: 1;
        }

        /* anchor button when hovered */
        .anchor:hover {
            cursor: pointer;
        }
    }

    /* always show anchor button on devices with no mouse/hover ability */
    @media (hover: none) {
        .anchor {
            opacity: 1;
        }
    }

    /* always hide anchor button on print */
    @media only print {
        .anchor {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* accordion plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* accordion arrow button */
        .accordion_arrow {
            margin-right: 10px;
        }

        /* arrow icon when <h2> data-collapsed attribute true */
        h2[data-collapsed="true"] > .accordion_arrow > svg {
            transform: rotate(-90deg);
        }

        /* all elements (except <h2>'s) when data-collapsed attribute true */
        *:not(h2)[data-collapsed="true"] {
            display: none;
        }

        /* accordion arrow button when hovered and <h2>'s when hovered */
        .accordion_arrow:hover,
        h2[data-collapsed="true"]:hover,
        h2[data-collapsed="false"]:hover {
            cursor: pointer;
        }
    }

    /* always hide accordion arrow button on print */
    @media only print {
        .accordion_arrow {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* tooltips plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* tooltip container */
        #tooltip {
            position: absolute;
            width: 50%;
            min-width: 240px;
            max-width: 75%;
            z-index: 1;
        }

        /* tooltip content */
        #tooltip_content {
            margin-bottom: 5px;
            padding: 20px;
            border-radius: 5px;
            border: solid 1px #bdbdbd;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            background: #ffffff;
            overflow-wrap: break-word;
        }

        /* tooltip copy of paragraphs and figures */
        #tooltip_content > p,
        #tooltip_content > figure {
            margin: 0;
            max-height: 320px;
            overflow-y: auto;
        }

        /* tooltip copy of <img> */
        #tooltip_content > figure > img {
            max-height: 260px;
        }

        /* navigation bar */
        #tooltip_nav_bar {
            margin-top: 10px;
            text-align: center;
        }

        /* navigation bar previous/next buton */
        #tooltip_nav_bar > .icon_button {
            position: relative;
            top: 3px;
        }

        /* navigation bar previous button */
        #tooltip_nav_bar > .icon_button:first-of-type {
            margin-right: 5px;
        }

        /* navigation bar next button */
        #tooltip_nav_bar > .icon_button:last-of-type {
            margin-left: 5px;
        }
    }

    /* always hide tooltip on print */
    @media only print {
        #tooltip {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* jump to first plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* jump button */
        .jump_arrow {
            position: relative;
            top: 0.125em;
            margin-right: 5px;
        }
    }

    /* always hide jump button on print */
    @media only print {
        .jump_arrow {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* link highlight plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* anything with data-highlighted attribute true */
        [data-highlighted="true"] {
            background: #ffeb3b;
        }

        /* anything with data-selected attribute true */
        [data-selected="true"] {
            background: #ff8a65 !important;
        }

        /* animation definition for glow */
        @keyframes highlight_glow {
            0% {
                background: none;
            }
            10% {
                background: #bbdefb;
            }
            100% {
                background: none;
            }
        }

        /* anything with data-glow attribute true */
        [data-glow="true"] {
            animation: highlight_glow 2s;
        }
    }

    /* -------------------------------------------------- */
    /* table of contents plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* toc panel */
        #toc_panel {
            box-sizing: border-box;
            position: fixed;
            top: 0;
            left: 0;
            background: #ffffff;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            z-index: 2;
        }

        /* toc panel when closed */
        #toc_panel[data-open="false"] {
            min-width: 60px;
            width: 60px;
            height: 60px;
            border-right: solid 1px #bdbdbd;
            border-bottom: solid 1px #bdbdbd;
        }

        /* toc panel when open */
        #toc_panel[data-open="true"] {
            min-width: 260px;
            max-width: 480px;
            /* keep panel edge consistent distance away from "page" edge */
            width: calc(((100vw - 8.5in) / 2) - 30px - 40px);
            bottom: 0;
            border-right: solid 1px #bdbdbd;
        }

        /* toc panel header */
        #toc_header {
            box-sizing: border-box;
            display: flex;
            flex-direction: row;
            align-items: center;
            height: 60px;
            margin: 0;
            padding: 20px;
        }

        /* toc panel header when hovered */
        #toc_header:hover {
            cursor: pointer;
        }

        /* toc panel header when panel open */
        #toc_panel[data-open="true"] > #toc_header {
            border-bottom: solid 1px #bdbdbd;
        }

        /* toc open/close header button */
        #toc_button {
            margin-right: 20px;
        }

        /* hide toc list and header text when closed */
        #toc_panel[data-open="false"] > #toc_header > *:not(#toc_button),
        #toc_panel[data-open="false"] > #toc_list {
            display: none;
        }

        /* toc list of entries */
        #toc_list {
            box-sizing: border-box;
            width: 100%;
            padding: 20px;
            position: absolute;
            top: calc(60px + 1px);
            bottom: 0;
            overflow: auto;
        }

        /* toc entry, link to section in document */
        .toc_link {
            display: block;
            padding: 5px;
            position: relative;
            font-weight: 600;
            text-decoration: none;
        }

        /* toc entry when hovered or when "viewed" */
        .toc_link:hover,
        .toc_link[data-viewing="true"] {
            background: #f5f5f5;
        }

        /* toc entry, level 1 indentation */
        .toc_link[data-level="1"] {
            margin-left: 0;
        }

        /* toc entry, level 2 indentation */
        .toc_link[data-level="2"] {
            margin-left: 20px;
        }

        /* toc entry, level 3 indentation */
        .toc_link[data-level="3"] {
            margin-left: 40px;
        }

        /* toc entry, level 4 indentation */
        .toc_link[data-level="4"] {
            margin-left: 60px;
        }

        /* toc entry bullets */
        #toc_panel[data-bullets="true"] .toc_link[data-level]:before {
            position: absolute;
            left: -15px;
            top: -1px;
            font-size: 1.5em;
        }

        /* toc entry, level 2 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="2"]:before {
            content: "\2022";
        }

        /* toc entry, level 3 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="3"]:before {
            content: "\25AB";
        }

        /* toc entry, level 4 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="4"]:before {
            content: "-";
        }
    }

    /* when on screen < 8.5in wide */
    @media only screen and (max-width: 8.5in) {
        /* push <body> ("page") element down to make room for toc icon */
        .toc_body_nudge {
            padding-top: 60px;
        }

        /* toc icon when panel closed and not hovered */
        #toc_panel[data-open="false"]:not(:hover) {
            background: rgba(255, 255, 255, 0.75);
        }
    }

    /* always hide toc panel on print */
    @media only print {
        #toc_panel {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* lightbox plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* regular <img> in document when hovered */
        .lightbox_document_img:hover {
            cursor: pointer;
        }

        .body_no_scroll {
            overflow: hidden !important;
        }

        /* screen overlay */
        #lightbox_overlay {
            display: flex;
            flex-direction: column;
            position: fixed;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 3;
        }

        /* middle area containing lightbox image */
        #lightbox_image_container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            padding: 20px;
        }

        /* bottom area containing caption */
        #lightbox_bottom_container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            min-height: 100px;
            max-height: 100px;
            background: rgba(0, 0, 0, 0.5);
        }

        /* image number info text box */
        #lightbox_number_info {
            position: absolute;
            color: #ffffff;
            font-weight: 600;
            left: 2px;
            top: 0;
            z-index: 4;
        }

        /* zoom info text box */
        #lightbox_zoom_info {
            position: absolute;
            color: #ffffff;
            font-weight: 600;
            right: 2px;
            top: 0;
            z-index: 4;
        }

        /* copy of image caption */
        #lightbox_caption {
            box-sizing: border-box;
            display: inline-block;
            width: 100%;
            max-height: 100%;
            padding: 10px 0;
            text-align: center;
            overflow-y: auto;
            color: #ffffff;
        }

        /* navigation previous/next button */
        .lightbox_button {
            width: 100px;
            height: 100%;
            min-width: 100px;
            min-height: 100%;
            color: #ffffff;
        }

        /* navigation previous/next button when hovered */
        .lightbox_button:hover {
            background: none !important;
        }

        /* navigation button icon */
        .lightbox_button > svg {
            height: 25px;
        }

        /* figure auto-number */
        #lightbox_caption > span:first-of-type {
            font-weight: bold;
            margin-right: 5px;
        }

        /* lightbox image when hovered */
        #lightbox_img:hover {
            cursor: grab;
        }

        /* lightbox image when grabbed */
        #lightbox_img:active {
            cursor: grabbing;
        }
    }

    /* when on screen < 480px wide */
    @media only screen and (max-width: 480px) {
        /* make navigation buttons skinnier on small screens to make more room for caption text */
        .lightbox_button {
            width: 50px;
            min-width: 50px;
        }
    }

    /* always hide lightbox on print */
    @media only print {
        #lightbox_overlay {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* hypothesis (annotations) plugin */
    /* -------------------------------------------------- */

    /* side panel */
    .annotator-frame {
        width: 280px !important;
        z-index: 0 !important;
    }

    /* match highlight color to rest of theme */
    .annotator-highlights-always-on .annotator-hl {
        background-color: #ffeb3b !important;
    }

    /* match focused color to rest of theme */
    .annotator-hl.annotator-hl-focused {
        background-color: #ff8a65 !important;
    }

    /* match bucket bar color to rest of theme */
    .annotator-bucket-bar {
        background: #f5f5f5 !important;
    }

    /* always hide toolbar and tooltip on print */
    @media only print {
        .annotator-frame {
            display: none !important;
        }

        hypothesis-adder {
            display: none !important;
        }
    }
</style>
<!-- anchors plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin adds an anchor next to each of a certain type
        // of element that provides a human-readable url to that specific
        // item/position in the document (eg "manuscript.html#abstract"). It
        // also makes it such that scrolling out of view of a target removes
        // its identifier from the url.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'anchors';

        // default plugin options
        const options = {
            // which types of elements to add anchors next to, in
            // "document.querySelector" format
            typesQuery: 'h1, h2, h3, [id^="fig:"], [id^="tbl:"], [id^="eq:"]',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // add anchor to each element of specified types
            const elements = document.querySelectorAll(options.typesQuery);
            for (const element of elements)
                addAnchor(element);

            // attach scroll listener to window
            window.addEventListener('scroll', onScroll);
        }

        // when window is scrolled
        function onScroll() {
            // if url has hash and user has scrolled out of view of hash
            // target, remove hash from url
            const tolerance = 100;
            const target = getHashTarget();
            if (target) {
                if (
                    target.getBoundingClientRect().top >
                        window.innerHeight + tolerance ||
                    target.getBoundingClientRect().bottom < 0 - tolerance
                )
                    history.pushState(null, null, ' ');
            }
        }

        // add anchor to element
        function addAnchor(element) {
            let addTo; // element to add anchor button to

            // if figure or table, modify withId and addTo to get expected
            // elements
            if (element.id.indexOf('fig:') === 0) {
                addTo = element.querySelector('figcaption');
            } else if (element.id.indexOf('tbl:') === 0) {
                addTo = element.querySelector('caption');
            } else if (element.id.indexOf('eq:') === 0) {
                addTo = element.querySelector('.eqnos-number');
            }

            addTo = addTo || element;
            const id = element.id || null;

            // do not add anchor if element doesn't have assigned id.
            // id is generated by pandoc and is assumed to be unique and
            // human-readable
            if (!id)
                return;

            // create anchor button
            const anchor = document.createElement('a');
            anchor.innerHTML = document.querySelector('.icon_link').innerHTML;
            anchor.title = 'Link to this part of the document';
            anchor.classList.add('icon_button', 'anchor');
            anchor.dataset.ignore = 'true';
            anchor.href = '#' + id;
            addTo.appendChild(anchor);
        }

        // get element that is target of link or url hash
        function getHashTarget() {
            const hash = window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (id.indexOf('fig:') === 0)
                target = target.querySelector('figure');
            if (id.indexOf('tbl:') === 0)
                target = target.querySelector('table');

            return target;
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- link icon -->

<template class="icon_link">
    <!-- modified from: https://fontawesome.com/icons/link -->
    <svg width="16" height="16" viewBox="0 0 512 512">
        <path
            fill="currentColor"
            d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"
        ></path>
    </svg>
</template>
<!-- accordion plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin allows sections of content under <h2> headings
        // to be collapsible.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'accordion';

        // default plugin options
        const options = {
            // whether to always start expanded ('false'), always start
            // collapsed ('true'), or start collapsed when screen small ('auto')
            startCollapsed: 'auto',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // run through each <h2> heading
            const headings = document.querySelectorAll('h2');
            for (const heading of headings) {
                addArrow(heading);

                // start expanded/collapsed based on option
                if (
                    options.startCollapsed === 'true' ||
                    (options.startCollapsed === 'auto' && isSmallScreen())
                )
                    collapseHeading(heading);
                else
                    expandHeading(heading);
            }

            // attach hash change listener to window
            window.addEventListener('hashchange', onHashChange);
        }

        // when hash (eg manuscript.html#introduction) changes
        function onHashChange() {
            const target = getHashTarget();
            if (target)
                goToElement(target);
        }

        // add arrow to heading
        function addArrow(heading) {
            // add arrow button
            const arrow = document.createElement('button');
            arrow.innerHTML = document.querySelector(
                '.icon_angle_down'
            ).innerHTML;
            arrow.classList.add('icon_button', 'accordion_arrow');
            heading.insertBefore(arrow, heading.firstChild);

            // attach click listener to heading and button
            heading.addEventListener('click', onHeadingClick);
            arrow.addEventListener('click', onArrowClick);
        }

        // determine if on mobile-like device with small screen
        function isSmallScreen() {
            return Math.min(window.innerWidth, window.innerHeight) < 480;
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // get element that is target of hash
        function getHashTarget(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (id.indexOf('fig:') === 0)
                target = target.querySelector('figure');
            if (id.indexOf('tbl:') === 0)
                target = target.querySelector('table');

            return target;
        }

        // when <h2> heading is clicked
        function onHeadingClick(event) {
            // only collapse if <h2> itself is target of click (eg, user did
            // not click on anchor within <h2>)
            if (event.target === this)
                toggleCollapse(this);
        }

        // when arrow button is clicked
        function onArrowClick() {
            toggleCollapse(this.parentNode);
        }

        // collapse section if expanded, expand if collapsed
        function toggleCollapse(heading) {
            if (heading.dataset.collapsed === 'false')
                collapseHeading(heading);
            else
                expandHeading(heading);
        }

        // elements to exclude from collapse, such as table of contents panel,
        // hypothesis panel, etc
        const exclude = '#toc_panel, div.annotator-frame, #lightbox_overlay';

        // collapse section
        function collapseHeading(heading) {
            heading.setAttribute('data-collapsed', 'true');
            const children = getChildren(heading);
            for (const child of children)
                child.setAttribute('data-collapsed', 'true');
        }

        // expand section
        function expandHeading(heading) {
            heading.setAttribute('data-collapsed', 'false');
            const children = getChildren(heading);
            for (const child of children)
                child.setAttribute('data-collapsed', 'false');
        }

        // get list of elements between this <h2> and next <h2> or <h1>
        // ("children" of the <h2> section)
        function getChildren(heading) {
            return nextUntil(heading, 'h2, h1', exclude);
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get list of elements after a start element up to element matching
        // query
        function nextUntil(element, query, exclude) {
            const elements = [];
            while (element = element.nextElementSibling, element) {
                if (element.matches(query))
                    break;
                if (!element.matches(exclude))
                    elements.push(element);
            }
            return elements;
        }

        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- angle down icon -->

<template class="icon_angle_down">
    <!-- modified from: https://fontawesome.com/icons/angle-down -->
    <svg width="16" height="16" viewBox="0 0 448 512">
        <path
            fill="currentColor"
            d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"
        ></path>
    </svg>
</template>
<!-- tooltips plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when the user hovers or
        // focuses a link to a citation or figure, a tooltip appears with a
        // preview of the reference content, along with arrows to navigate
        // between instances of the same reference in the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'tooltips';

        // default plugin options
        const options = {
            // whether user must click off to close tooltip instead of just
            // un-hovering
            clickClose: 'false',
            // delay (in ms) between opening and closing tooltip
            delay: '100',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            const links = getLinks();
            for (const link of links) {
                // attach hover and focus listeners to link
                link.addEventListener('mouseover', onLinkHover);
                link.addEventListener('mouseleave', onLinkUnhover);
                link.addEventListener('focus', onLinkFocus);
                link.addEventListener('touchend', onLinkTouch);
            }

            // attach mouse, key, and resize listeners to window
            window.addEventListener('mousedown', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onResize);
        }

        // when link is hovered
        function onLinkHover() {
            // function to open tooltip
            const delayOpenTooltip = function() {
                openTooltip(this);
            }.bind(this);

            // run open function after delay
            this.openTooltipTimer = window.setTimeout(
                delayOpenTooltip,
                options.delay
            );
        }

        // when mouse leaves link
        function onLinkUnhover() {
            // cancel opening tooltip
            window.clearTimeout(this.openTooltipTimer);

            // don't close on unhover if option specifies
            if (options.clickClose === 'true')
                return;

            // function to close tooltip
            const delayCloseTooltip = function() {
                // if tooltip open and if mouse isn't over tooltip, close
                const tooltip = document.getElementById('tooltip');
                if (tooltip && !tooltip.matches(':hover'))
                    closeTooltip();
            };

            // run close function after delay
            this.closeTooltipTimer = window.setTimeout(
                delayCloseTooltip,
                options.delay
            );
        }

        // when link is focused (tabbed to)
        function onLinkFocus(event) {
            openTooltip(this);
        }

        // when link is touched on touch screen
        function onLinkTouch(event) {
            // attempt to force hover state on first tap always, and trigger
            // regular link click (and navigation) on second tap
            if (event.target === document.activeElement)
                event.target.click();
            else {
                document.activeElement.blur();
                event.target.focus();
            }
            if (event.cancelable)
                event.preventDefault();
            event.stopPropagation();
            return false;
        }

        // when mouse is clicked anywhere in window
        function onClick(event) {
            closeTooltip();
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            switch (event.key) {
                // trigger click of prev button
                case 'ArrowLeft':
                    const prevButton = document.getElementById(
                        'tooltip_prev_button'
                    );
                    if (prevButton)
                        prevButton.click();
                    break;
                // trigger click of next button
                case 'ArrowRight':
                    const nextButton = document.getElementById(
                        'tooltip_next_button'
                    );
                    if (nextButton)
                        nextButton.click();
                    break;
                // close on esc
                case 'Escape':
                    closeTooltip();
                    break;
            }
        }

        // when window is resized or zoomed
        function onResize() {
            closeTooltip();
        }

        // get all links of types we wish to handle
        function getLinks() {
            const queries = [];
            // exclude buttons, anchor links, toc links, etc
            const exclude =
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            queries.push('a[href^="#ref-"]' + exclude); // citation links
            queries.push('a[href^="#fig:"]' + exclude); // figure links
            const query = queries.join(', ');
            return document.querySelectorAll(query);
        }

        // get links with same target, get index of link in set, get total
        // same links
        function getSameLinks(link) {
            const sameLinks = [];
            const links = getLinks();
            for (const otherLink of links) {
                if (
                    otherLink.getAttribute('href') === link.getAttribute('href')
                )
                    sameLinks.push(otherLink);
            }

            return {
                elements: sameLinks,
                index: sameLinks.indexOf(link),
                total: sameLinks.length
            };
        }

        // open tooltip
        function openTooltip(link) {
            // delete tooltip if it exists, start fresh
            closeTooltip();

            // make tooltip element
            const tooltip = makeTooltip(link);

            // if source couldn't be found and tooltip not made, exit
            if (!tooltip)
                return;

            // make navbar elements
            const navBar = makeNavBar(link);
            if (navBar)
                tooltip.firstElementChild.appendChild(navBar);

            // attach tooltip to page
            document.body.appendChild(tooltip);

            // position tooltip
            const position = function() {
                positionTooltip(link);
            };
            position();

            // if tooltip contains images, position again after they've loaded
            const imgs = tooltip.querySelectorAll('img');
            for (const img of imgs)
                img.addEventListener('load', position);
        }

        // close (delete) tooltip
        function closeTooltip() {
            const tooltip = document.getElementById('tooltip');
            if (tooltip)
                tooltip.remove();
        }

        // make tooltip
        function makeTooltip(link) {
            // get target element that link points to
            const source = getSource(link);

            // if source can't be found, exit
            if (!source)
                return;

            // create new tooltip
            const tooltip = document.createElement('div');
            tooltip.id = 'tooltip';
            const tooltipContent = document.createElement('div');
            tooltipContent.id = 'tooltip_content';
            tooltip.appendChild(tooltipContent);

            // make copy of source node and put in tooltip
            const sourceCopy = makeCopy(source);
            tooltipContent.appendChild(sourceCopy);

            // attach mouse event listeners
            tooltip.addEventListener('click', onTooltipClick);
            tooltip.addEventListener('mousedown', onTooltipClick);
            tooltip.addEventListener('touchstart', onTooltipClick);
            tooltip.addEventListener('mouseleave', onTooltipUnhover);

            // (for interaction with lightbox plugin)
            // transfer click on tooltip copied img to original img
            const sourceImg = source.querySelector('img');
            const sourceCopyImg = sourceCopy.querySelector('img');
            if (sourceImg && sourceCopyImg) {
                const clickImg = function() {
                    sourceImg.click();
                    closeTooltip();
                };
                sourceCopyImg.addEventListener('click', clickImg);
            }

            return tooltip;
        }

        // make carbon copy of html dom element
        function makeCopy(source) {
            const sourceCopy = source.cloneNode(true);

            // delete elements marked with ignore (eg anchor and jump buttons)
            const deleteFromCopy = sourceCopy.querySelectorAll(
                '[data-ignore="true"]'
            );
            for (const element of deleteFromCopy)
                element.remove();

            // delete certain element attributes
            const attributes = [
                'id',
                'data-collapsed',
                'data-selected',
                'data-highlighted',
                'data-glow'
            ];
            for (const attribute of attributes) {
                sourceCopy.removeAttribute(attribute);
                const elements = sourceCopy.querySelectorAll(
                    '[' + attribute + ']'
                );
                for (const element of elements)
                    element.removeAttribute(attribute);
            }

            return sourceCopy;
        }

        // when tooltip is clicked
        function onTooltipClick(event) {
            // when user clicks on tooltip, stop click from transferring
            // outside of tooltip (eg, click off to close tooltip, or eg click
            // off to unhighlight same refs)
            event.stopPropagation();
        }

        // when tooltip is unhovered
        function onTooltipUnhover(event) {
            if (options.clickClose === 'true')
                return;

            // make sure new mouse/touch/focus no longer over tooltip or any
            // element within it
            const tooltip = document.getElementById('tooltip');
            if (!tooltip)
                return;
            if (this.contains(event.relatedTarget))
                return;

            closeTooltip();
        }

        // make nav bar to go betwen prev/next instances of same reference
        function makeNavBar(link) {
            // find other links to the same source
            const sameLinks = getSameLinks(link);

            // don't show nav bar when singular reference
            if (sameLinks.total <= 1)
                return;

            // find prev/next links with same target
            const prevLink = getPrevLink(link, sameLinks);
            const nextLink = getNextLink(link, sameLinks);

            // create nav bar
            const navBar = document.createElement('div');
            navBar.id = 'tooltip_nav_bar';
            const text = sameLinks.index + 1 + ' of ' + sameLinks.total;

            // create nav bar prev/next buttons
            const prevButton = document.createElement('button');
            const nextButton = document.createElement('button');
            prevButton.id = 'tooltip_prev_button';
            nextButton.id = 'tooltip_next_button';
            prevButton.title =
                'Jump to the previous occurence of this item in the document [←]';
            nextButton.title =
                'Jump to the next occurence of this item in the document [→]';
            prevButton.classList.add('icon_button');
            nextButton.classList.add('icon_button');
            prevButton.innerHTML = document.querySelector(
                '.icon_caret_left'
            ).innerHTML;
            nextButton.innerHTML = document.querySelector(
                '.icon_caret_right'
            ).innerHTML;
            navBar.appendChild(prevButton);
            navBar.appendChild(document.createTextNode(text));
            navBar.appendChild(nextButton);

            // attach click listeners to buttons
            prevButton.addEventListener('click', function() {
                onPrevNextClick(link, prevLink);
            });
            nextButton.addEventListener('click', function() {
                onPrevNextClick(link, nextLink);
            });

            return navBar;
        }

        // get previous link with same target
        function getPrevLink(link, sameLinks) {
            if (!sameLinks)
                sameLinks = getSameLinks(link);
            // wrap index to other side if < 1
            let index;
            if (sameLinks.index - 1 >= 0)
                index = sameLinks.index - 1;
            else
                index = sameLinks.total - 1;
            return sameLinks.elements[index];
        }

        // get next link with same target
        function getNextLink(link, sameLinks) {
            if (!sameLinks)
                sameLinks = getSameLinks(link);
            // wrap index to other side if > total
            let index;
            if (sameLinks.index + 1 <= sameLinks.total - 1)
                index = sameLinks.index + 1;
            else
                index = 0;
            return sameLinks.elements[index];
        }

        // get element that is target of link or url hash
        function getSource(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            // if ref or figure, modify target to get expected element
            if (id.indexOf('ref-') === 0)
                target = target.querySelector('p');
            else if (id.indexOf('fig:') === 0)
                target = target.querySelector('figure');

            return target;
        }

        // when prev/next arrow button is clicked
        function onPrevNextClick(link, prevNextLink) {
            if (link && prevNextLink)
                goToElement(prevNextLink, window.innerHeight * 0.5);
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // determine position to place tooltip based on link position in
        // viewport and tooltip size
        function positionTooltip(link, left, top) {
            const tooltipElement = document.getElementById('tooltip');
            if (!tooltipElement)
                return;

            // get convenient vars for position/dimensions of
            // link/tooltip/page/view
            link = getRectInPage(link);
            const tooltip = getRectInPage(tooltipElement);
            const view = getRectInPage();

            // horizontal positioning
            if (left)
                // use explicit value
                left = left;
            else if (link.left + tooltip.width < view.right)
                // fit tooltip to right of link
                left = link.left;
            else if (link.right - tooltip.width > view.left)
                // fit tooltip to left of link
                left = link.right - tooltip.width;
            // center tooltip in view
            else
                left = (view.right - view.left) / 2 - tooltip.width / 2;

            // vertical positioning
            if (top)
                // use explicit value
                top = top;
            else if (link.top - tooltip.height > view.top)
                // fit tooltip above link
                top = link.top - tooltip.height;
            else if (link.bottom + tooltip.height < view.bottom)
                // fit tooltip below link
                top = link.bottom;
            else {
                // center tooltip in view
                top = view.top + view.height / 2 - tooltip.height / 2;
                // nudge off of link to left/right if possible
                if (link.right + tooltip.width < view.right)
                    left = link.right;
                else if (link.left - tooltip.width > view.left)
                    left = link.left - tooltip.width;
            }

            tooltipElement.style.left = left + 'px';
            tooltipElement.style.top = top + 'px';
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get position of element relative to page
        function getRectInPage(element) {
            const rect = getRectInView(element);
            const body = getRectInView(document.body);

            const newRect = {};
            newRect.left = rect.left - body.left;
            newRect.top = rect.top - body.top;
            newRect.right = rect.right - body.left;
            newRect.bottom = rect.bottom - body.top;
            newRect.width = rect.width;
            newRect.height = rect.height;

            return newRect;
        }

        // (for interaction with accordion plugin)
        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // (for interaction with accordion plugin)
        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // (for interaction with accordion plugin)
        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- caret left icon -->

<template class="icon_caret_left">
    <!-- modified from: https://fontawesome.com/icons/caret-left -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M192 127.338v257.324c0 17.818-21.543 26.741-34.142 14.142L29.196 270.142c-7.81-7.81-7.81-20.474 0-28.284l128.662-128.662c12.599-12.6 34.142-3.676 34.142 14.142z"
        ></path>
    </svg>
</template>

<!-- caret right icon -->

<template class="icon_caret_right">
    <!-- modified from: https://fontawesome.com/icons/caret-right -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z"
        ></path>
    </svg>
</template>
<!-- jump to first plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin adds a button next to each reference entry,
        // figure, and table that jumps the page to the first occurrence of a
        // link to that item in the manuscript.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'jumpToFirst';

        // default plugin options
        const options = {
            // whether to add buttons next to reference entries
            references: 'true',
            // whether to add buttons next to figures
            figures: 'true',
            // whether to add buttons next to tables
            tables: 'true',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            if (options.references !== 'false')
                makeReferenceButtons();
            if (options.figures !== 'false')
                makeFigureButtons();
            if (options.tables !== 'false')
                makeTableButtons();
        }

        // when jump button clicked
        function onButtonClick() {
            const first = getFirstOccurrence(this.dataset.id);
            if (!first)
                return;

            // update url hash so navigating "back" in history will return
            // user to jump button
            window.location.hash = this.dataset.id;
            // scroll to link
            window.setTimeout(function() {
                goToElement(first, window.innerHeight * 0.5);
            }, 0);
        }

        // get first occurence of link to item in document
        function getFirstOccurrence(id) {
            let query = 'a';
            query += '[href="#' + id + '"]';
            // exclude buttons, anchor links, toc links, etc
            query +=
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            return document.querySelector(query);
        }

        // add button next to each reference entry
        function makeReferenceButtons() {
            const references = document.querySelectorAll('div[id^="ref-"]');
            for (const reference of references) {
                // get reference id and element to add button to
                const id = reference.id;
                const container = reference.firstElementChild;
                const first = getFirstOccurrence(id);

                // if can't find link to reference, ignore
                if (!first)
                    continue;

                // make jump button
                let button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this reference in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.innerHTML = button.outerHTML + container.innerHTML;
                button = container.firstElementChild;
                button.addEventListener('click', onButtonClick);
            }
        }

        // add button next to each figure
        function makeFigureButtons() {
            const figures = document.querySelectorAll('[id^="fig:"]');
            for (const figure of figures) {
                // get figure id and element to add button to
                const id = figure.id;
                const container = figure.querySelector('figcaption') || figure;
                const first = getFirstOccurrence(id);

                // if can't find link to figure, ignore
                if (!first)
                    continue;

                // make jump button
                const button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this figure in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.insertBefore(button, container.firstElementChild);
                button.addEventListener('click', onButtonClick);
            }
        }

        // add button next to each figure
        function makeTableButtons() {
            const tables = document.querySelectorAll('[id^="tbl:"]');
            for (const table of tables) {
                // get ref id and element to add button to
                const id = table.id;
                const container = table.querySelector('caption') || table;
                const first = getFirstOccurrence(id);

                // if can't find link to table, ignore
                if (!first)
                    continue;

                // make jump button
                const button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this table in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.insertBefore(button, container.firstElementChild);
                button.addEventListener('click', onButtonClick);
            }
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // (for interaction with accordion plugin)
        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- angle double up icon -->

<template class="icon_angle_double_up">
    <!-- modified from: https://fontawesome.com/icons/angle-double-up -->
    <svg width="16" height="16" viewBox="0 0 320 512">
        <path
            fill="currentColor"
            d="M177 255.7l136 136c9.4 9.4 9.4 24.6 0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9 0L160 351.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9 0L7 425.7c-9.4-9.4-9.4-24.6 0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1zm-34-192L7 199.7c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l96.4-96.4 96.4 96.4c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9l-136-136c-9.2-9.4-24.4-9.4-33.8 0z"
        ></path>
    </svg>
</template>
<!-- link highlight plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when a user hovers or
        // focuses a link, other links that have the same target will be
        // highlighted. It also makes it such that when clicking a link, the
        // target of the link (eg reference, figure, table) is briefly
        // highlighted.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'linkHighlight';

        // default plugin options
        const options = {
            // whether to also highlight links that go to external urls
            externalLinks: 'false',
            // whether user must click off to unhighlight instead of just
            // un-hovering
            clickUnhighlight: 'false',
            // whether to also highlight links that are unique
            highlightUnique: 'true',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            const links = getLinks();
            for (const link of links) {
                // attach mouse and focus listeners to link
                link.addEventListener('mouseenter', onLinkFocus);
                link.addEventListener('focus', onLinkFocus);
                link.addEventListener('mouseleave', onLinkUnhover);
            }

            // attach click and hash change listeners to window
            window.addEventListener('click', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('hashchange', onHashChange);

            // run hash change on window load in case user has navigated
            // directly to hash
            onHashChange();
        }

        // when link is focused (tabbed to) or hovered
        function onLinkFocus() {
            highlight(this);
        }

        // when link is unhovered
        function onLinkUnhover() {
            if (options.clickUnhighlight !== 'true')
                unhighlightAll();
        }

        // when the mouse is clicked anywhere in window
        function onClick(event) {
            unhighlightAll();
        }

        // when hash (eg manuscript.html#introduction) changes
        function onHashChange() {
            const target = getHashTarget();
            if (target)
                glowElement(target);
        }

        // get element that is target of link or url hash
        function getHashTarget(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            return target;
        }

        // start glow sequence on an element
        function glowElement(element) {
            const startGlow = function() {
                onGlowEnd();
                element.dataset.glow = 'true';
                element.addEventListener('animationend', onGlowEnd);
            };
            const onGlowEnd = function() {
                element.removeAttribute('data-glow');
                element.removeEventListener('animationend', onGlowEnd);
            };
            startGlow();
        }

        // highlight link and all others with same target
        function highlight(link) {
            // force unhighlight all to start fresh
            unhighlightAll();

            // get links with same target
            if (!link)
                return;
            const sameLinks = getSameLinks(link);

            // if link unique and option is off, exit and don't highlight
            if (sameLinks.length <= 1 && options.highlightUnique !== 'true')
                return;

            // highlight all same links, and "select" (special highlight) this
            // one
            for (const sameLink of sameLinks) {
                if (sameLink === link)
                    sameLink.setAttribute('data-selected', 'true');
                else
                    sameLink.setAttribute('data-highlighted', 'true');
            }
        }

        // unhighlight all links
        function unhighlightAll() {
            const links = getLinks();
            for (const link of links) {
                link.setAttribute('data-selected', 'false');
                link.setAttribute('data-highlighted', 'false');
            }
        }

        // get links with same target
        function getSameLinks(link) {
            const results = [];
            const links = getLinks();
            for (const otherLink of links) {
                if (
                    otherLink.getAttribute('href') === link.getAttribute('href')
                )
                    results.push(otherLink);
            }
            return results;
        }

        // get all links of types we wish to handle
        function getLinks() {
            let query = 'a';
            if (options.externalLinks !== 'true')
                query += '[href^="#"]';
            // exclude buttons, anchor links, toc links, etc
            query +=
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            return document.querySelectorAll(query);
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>
<!-- table of contents plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin provides a "table of contents" (toc) panel on
        // the side of the document that allows the user to conveniently
        // navigate between sections of the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'tableOfContents';

        // default plugin options
        const options = {
            // which types of elements to add links for, in
            // "document.querySelector" format
            typesQuery: 'h1, h2, h3',
            // whether default behavior is to be closed ('false'), open
            // ('true'), or only open when screen wide enough to fit panel
            // ('auto'). note: still always starts closed when page loads.
            open: 'auto',
            // if list item is more than this many characters, text will be
            // truncated
            charLimit: '50',
            // whether or not to show bullets next to each toc item
            bullets: 'false',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // make toc panel and populate with entries (links to document
            // sections)
            const panel = makePanel();
            if (!panel)
                return;
            makeEntries(panel);
            document.body.insertBefore(panel, document.body.firstChild);

            closePanel();

            // attach click, scroll, and hash change listeners to window
            window.addEventListener('click', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('scroll', onScroll);
            window.addEventListener('hashchange', onScroll);
            window.addEventListener('keyup', onKeyUp);
            onScroll();

            // add class to push document body down out of way of toc button
            document.body.classList.add('toc_body_nudge');
        }

        // determine if screen wide enough to fit toc panel
        function isSmallScreen() {
            // in default theme:
            // 816px = 8.5in = width of "page" (<body>) element
            // 260px = min width of toc panel (*2 for both sides of <body>)
            return window.innerWidth < 816 + 260 * 2;
        }

        // open/close panel based on option and screen size
        function openOrClosePanel() {
            if (
                options.open === 'true' ||
                (options.open === 'auto' && !isSmallScreen())
            )
                openPanel();
            else
                closePanel();
        }

        // when mouse is clicked anywhere in window
        function onClick() {
            const panel = document.getElementById('toc_panel');
            if (!panel)
                return;

            if (panel.dataset.open === 'true')
                openOrClosePanel();
        }

        // when window is scrolled or hash changed
        function onScroll() {
            highlightViewed();
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            // close on esc
            if (event.key === 'Escape')
                closePanel();
        }

        // find entry of currently viewed document section in toc and highlight
        function highlightViewed() {
            const firstId = getFirstInView(options.typesQuery);

            // get toc entries (links), unhighlight all, then highlight viewed
            const list = document.getElementById('toc_list');
            if (!firstId || !list)
                return;
            const links = list.querySelectorAll('a');
            for (const link of links)
                link.dataset.viewing = 'false';
            const link = list.querySelector('a[href="#' + firstId + '"]');
            if (!link)
                return;
            link.dataset.viewing = 'true';
        }

        // get first or previous toc listed element in top half of view
        function getFirstInView(query) {
            // get all elements matching query and with id
            const elements = document.querySelectorAll(query);
            const elementsWithIds = [];
            for (const element of elements) {
                if (element.id)
                    elementsWithIds.push(element);
            }


            // get first or previous element in top half of view
            for (let i = 0; i < elementsWithIds.length; i++) {
                const element = elementsWithIds[i];
                const prevElement = elementsWithIds[Math.max(0, i - 1)];
                if (element.getBoundingClientRect().top >= 0) {
                    if (
                        element.getBoundingClientRect().top <
                        window.innerHeight / 2
                    )
                        return element.id;
                    else
                        return prevElement.id;
                }
            }
        }

        // make panel
        function makePanel() {
            // create panel
            const panel = document.createElement('div');
            panel.id = 'toc_panel';
            if (options.bullets === 'true')
                panel.dataset.bullets = 'true';

            // create header
            const header = document.createElement('div');
            header.id = 'toc_header';

            // create toc button
            const button = document.createElement('button');
            button.id = 'toc_button';
            button.innerHTML = document.querySelector(
                '.icon_th_list'
            ).innerHTML;
            button.classList.add('icon_button');

            // create header text
            const text = document.createElement('h3');
            text.innerHTML = 'Table of Contents';

            // create container for toc list
            const list = document.createElement('div');
            list.id = 'toc_list';

            // attach click listeners
            panel.addEventListener('click', onPanelClick);
            header.addEventListener('click', onHeaderClick);
            button.addEventListener('click', onButtonClick);

            // attach elements
            header.appendChild(button);
            header.appendChild(text);
            panel.appendChild(header);
            panel.appendChild(list);

            return panel;
        }

        // create toc entries (links) to each element of the specified types
        function makeEntries(panel) {
            const elements = document.querySelectorAll(options.typesQuery);
            for (const element of elements) {
                // do not add link if element doesn't have assigned id
                if (!element.id)
                    continue;

                // create link/list item
                const link = document.createElement('a');
                link.classList.add('toc_link');
                switch (element.tagName.toLowerCase()) {
                    case 'h1':
                        link.dataset.level = '1';
                        break;
                    case 'h2':
                        link.dataset.level = '2';
                        break;
                    case 'h3':
                        link.dataset.level = '3';
                        break;
                    case 'h4':
                        link.dataset.level = '4';
                        break;
                }
                link.title = element.innerText;
                let text = element.innerText;
                if (text.length > options.charLimit)
                    text = text.slice(0, options.charLimit) + '...';
                link.innerHTML = text;
                link.href = '#' + element.id;
                link.addEventListener('click', onLinkClick);

                // attach link
                panel.querySelector('#toc_list').appendChild(link);
            }
        }

        // when panel is clicked
        function onPanelClick(event) {
            // stop click from propagating to window/document and closing panel
            event.stopPropagation();
        }

        // when header itself is clicked
        function onHeaderClick(event) {
            togglePanel();
        }

        // when button is clicked
        function onButtonClick(event) {
            togglePanel();
            // stop header underneath button from also being clicked
            event.stopPropagation();
        }

        // when link is clicked
        function onLinkClick() {
            openOrClosePanel();
        }

        // open panel if closed, close if opened
        function togglePanel() {
            const panel = document.getElementById('toc_panel');
            if (!panel)
                return;

            if (panel.dataset.open === 'true')
                closePanel();
            else
                openPanel();
        }

        // open panel
        function openPanel() {
            const panel = document.getElementById('toc_panel');
            if (panel)
                panel.dataset.open = 'true';
        }

        // close panel
        function closePanel() {
            const panel = document.getElementById('toc_panel');
            if (panel)
                panel.dataset.open = 'false';
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- th list icon -->

<template class="icon_th_list">
    <!-- modified from: https://fontawesome.com/icons/th-list -->
    <svg width="16" height="16" viewBox="0 0 512 512" tabindex="-1">
        <path
            fill="currentColor"
            d="M96 96c0 26.51-21.49 48-48 48S0 122.51 0 96s21.49-48 48-48 48 21.49 48 48zM48 208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm0 160c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm96-236h352c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h352c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h352c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"
            tabindex="-1"
        ></path>
    </svg>
</template>
<!-- lightbox plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when a user clicks on an
        // image, the image fills the screen and the user can pan/drag/zoom
        // the image and navigate between other images in the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'lightbox';

        // default plugin options
        const options = {
            // list of possible zoom/scale factors
            zoomSteps:
                '0.1, 0.25, 0.333333, 0.5, 0.666666, 0.75, 1,' +
                '1.25, 1.5, 1.75, 2, 2.5, 3, 3.5, 4, 5, 6, 7, 8',
            // whether to fit image to view ('fit'), display at 100% and shrink
            // if necessary ('shrink'), or always display at 100% ('100')
            defaultZoom: 'fit',
            // whether to zoom in/out toward center of view ('true') or mouse
            // ('false')
            centerZoom: 'false',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // run through each <img> element
            const imgs = document.querySelectorAll('figure > img');
            let count = 1;
            for (const img of imgs) {
                img.classList.add('lightbox_document_img');
                img.dataset.number = count;
                img.dataset.total = imgs.length;
                img.addEventListener('click', openLightbox);
                count++;
            }

            // attach mouse and key listeners to window
            window.addEventListener('mousemove', onWindowMouseMove);
            window.addEventListener('keyup', onKeyUp);
        }

        // when mouse is moved anywhere in window
        function onWindowMouseMove(event) {
            window.mouseX = event.clientX;
            window.mouseY = event.clientY;
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            switch (event.key) {
                // trigger click of prev button
                case 'ArrowLeft':
                    const prevButton = document.getElementById(
                        'lightbox_prev_button'
                    );
                    if (prevButton)
                        prevButton.click();
                    break;
                // trigger click of next button
                case 'ArrowRight':
                    const nextButton = document.getElementById(
                        'lightbox_next_button'
                    );
                    if (nextButton)
                        nextButton.click();
                    break;
                // close on esc
                case 'Escape':
                    closeLightbox();
                    break;
            }
        }

        // open lightbox
        function openLightbox() {
            const lightbox = makeLightbox(this);
            if (!lightbox)
                return;

            blurBody(lightbox);
            document.body.appendChild(lightbox);
        }

        // make lightbox
        function makeLightbox(img) {
            // delete lightbox if it exists, start fresh
            closeLightbox();

            // create screen overlay containing lightbox
            const overlay = document.createElement('div');
            overlay.id = 'lightbox_overlay';

            // create image info boxes
            const numberInfo = document.createElement('div');
            const zoomInfo = document.createElement('div');
            numberInfo.id = 'lightbox_number_info';
            zoomInfo.id = 'lightbox_zoom_info';

            // create container for image
            const imageContainer = document.createElement('div');
            imageContainer.id = 'lightbox_image_container';
            const lightboxImg = makeLightboxImg(
                img,
                imageContainer,
                numberInfo,
                zoomInfo
            );
            imageContainer.appendChild(lightboxImg);

            // create bottom container for caption and navigation buttons
            const bottomContainer = document.createElement('div');
            bottomContainer.id = 'lightbox_bottom_container';
            const caption = makeCaption(img);
            const prevButton = makePrevButton(img);
            const nextButton = makeNextButton(img);
            bottomContainer.appendChild(prevButton);
            bottomContainer.appendChild(caption);
            bottomContainer.appendChild(nextButton);

            // attach top middle and bottom to overlay
            overlay.appendChild(numberInfo);
            overlay.appendChild(zoomInfo);
            overlay.appendChild(imageContainer);
            overlay.appendChild(bottomContainer);

            return overlay;
        }

        // make <img> object that is intuitively draggable and zoomable
        function makeLightboxImg(
            sourceImg,
            container,
            numberInfoBox,
            zoomInfoBox
        ) {
            // create copy of source <img>
            const img = sourceImg.cloneNode(true);
            img.classList.remove('lightbox_document_img');
            img.removeAttribute('id');
            img.removeAttribute('width');
            img.removeAttribute('height');
            img.style.position = 'unset';
            img.style.margin = '0';
            img.style.padding = '0';
            img.style.width = '';
            img.style.height = '';
            img.style.minWidth = '';
            img.style.minHeight = '';
            img.style.maxWidth = '';
            img.style.maxHeight = '';
            img.id = 'lightbox_img';

            // build sorted list of unique zoomSteps, always including a 100%
            let zoomSteps = [];
            const optionsZooms = options.zoomSteps.split(/[^0-9.]/);
            for (const optionZoom of optionsZooms) {
                const newZoom = parseFloat(optionZoom);
                if (newZoom && !zoomSteps.includes(newZoom))
                    zoomSteps.push(newZoom);
            }
            if (!zoomSteps.includes(1))
                zoomSteps.push(1);
            zoomSteps = zoomSteps.sort(function sortNumber(a, b) {
                return a - b;
            });

            // <img> object property variables
            let zoom = 1;
            let translateX = 0;
            let translateY = 0;
            let clickMouseX = undefined;
            let clickMouseY = undefined;
            let clickTranslateX = undefined;
            let clickTranslateY = undefined;

            updateNumberInfo();

            // update image numbers displayed in info box
            function updateNumberInfo() {
                numberInfoBox.innerHTML =
                    sourceImg.dataset.number + ' of ' + sourceImg.dataset.total;
            }

            // update zoom displayed in info box
            function updateZoomInfo() {
                let zoomInfo = zoom * 100;
                if (!Number.isInteger(zoomInfo))
                    zoomInfo = zoomInfo.toFixed(2);
                zoomInfoBox.innerHTML = zoomInfo + '%';
            }

            // move to closest zoom step above current zoom
            const zoomIn = function() {
                for (const zoomStep of zoomSteps) {
                    if (zoomStep > zoom) {
                        zoom = zoomStep;
                        break;
                    }
                }
                updateTransform();
            };

            // move to closest zoom step above current zoom
            const zoomOut = function() {
                zoomSteps.reverse();
                for (const zoomStep of zoomSteps) {
                    if (zoomStep < zoom) {
                        zoom = zoomStep;
                        break;
                    }
                }
                zoomSteps.reverse();

                updateTransform();
            };

            // update display of <img> based on scale/translate properties
            const updateTransform = function() {
                // set transform
                img.style.transform =
                    'translate(' +
                    (translateX || 0) +
                    'px,' +
                    (translateY || 0) +
                    'px) scale(' +
                    (zoom || 1) +
                    ')';

                // get new width/height after scale
                const rect = img.getBoundingClientRect();
                // limit translate
                translateX = Math.max(translateX, -rect.width / 2);
                translateX = Math.min(translateX, rect.width / 2);
                translateY = Math.max(translateY, -rect.height / 2);
                translateY = Math.min(translateY, rect.height / 2);

                // set transform
                img.style.transform =
                    'translate(' +
                    (translateX || 0) +
                    'px,' +
                    (translateY || 0) +
                    'px) scale(' +
                    (zoom || 1) +
                    ')';

                updateZoomInfo();
            };

            // fit <img> to container
            const fit = function() {
                // no x/y offset, 100% zoom by default
                translateX = 0;
                translateY = 0;
                zoom = 1;

                // widths of <img> and container
                const imgWidth = img.naturalWidth;
                const imgHeight = img.naturalHeight;
                const containerWidth = parseFloat(
                    window.getComputedStyle(container).width
                );
                const containerHeight = parseFloat(
                    window.getComputedStyle(container).height
                );

                // how much zooming is needed to fit <img> to container
                const xRatio = imgWidth / containerWidth;
                const yRatio = imgHeight / containerHeight;
                const maxRatio = Math.max(xRatio, yRatio);
                const newZoom = 1 / maxRatio;

                // fit <img> to container according to option
                if (options.defaultZoom === 'shrink') {
                    if (maxRatio > 1)
                        zoom = newZoom;
                } else if (options.defaultZoom === 'fit')
                    zoom = newZoom;

                updateTransform();
            };

            // when mouse wheel is rolled anywhere in container
            const onContainerWheel = function(event) {
                if (!event)
                    return;

                // let ctrl + mouse wheel to zoom behave as normal
                if (event.ctrlKey)
                    return;

                // prevent normal scroll behavior
                event.preventDefault();
                event.stopPropagation();

                // point around which to scale img
                const viewRect = container.getBoundingClientRect();
                const viewX = (viewRect.left + viewRect.right) / 2;
                const viewY = (viewRect.top + viewRect.bottom) / 2;
                const originX = options.centerZoom === 'true' ? viewX : mouseX;
                const originY = options.centerZoom === 'true' ? viewY : mouseY;

                // get point on image under origin
                const oldRect = img.getBoundingClientRect();
                const oldPercentX = (originX - oldRect.left) / oldRect.width;
                const oldPercentY = (originY - oldRect.top) / oldRect.height;

                // increment/decrement zoom
                if (event.deltaY < 0)
                    zoomIn();
                if (event.deltaY > 0)
                    zoomOut();

                // get offset between previous image point and origin
                const newRect = img.getBoundingClientRect();
                const offsetX =
                    originX - (newRect.left + newRect.width * oldPercentX);
                const offsetY =
                    originY - (newRect.top + newRect.height * oldPercentY);

                // translate image to keep image point under origin
                translateX += offsetX;
                translateY += offsetY;

                // perform translate
                updateTransform();
            };

            // when container is clicked
            function onContainerClick(event) {
                // if container itself is target of click, and not other
                // element above it
                if (event.target === this)
                    closeLightbox();
            }

            // when mouse button is pressed on image
            const onImageMouseDown = function(event) {
                // store original mouse position relative to image
                clickMouseX = window.mouseX;
                clickMouseY = window.mouseY;
                clickTranslateX = translateX;
                clickTranslateY = translateY;
                event.stopPropagation();
                event.preventDefault();
            };

            // when mouse button is released anywhere in window
            const onWindowMouseUp = function(event) {
                // reset original mouse position
                clickMouseX = undefined;
                clickMouseY = undefined;
                clickTranslateX = undefined;
                clickTranslateY = undefined;

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('mouseup', onWindowMouseUp);
            };

            // when mouse is moved anywhere in window
            const onWindowMouseMove = function(event) {
                if (
                    clickMouseX === undefined ||
                    clickMouseY === undefined ||
                    clickTranslateX === undefined ||
                    clickTranslateY === undefined
                )
                    return;

                // offset image based on original and current mouse position
                translateX = clickTranslateX + window.mouseX - clickMouseX;
                translateY = clickTranslateY + window.mouseY - clickMouseY;
                updateTransform();
                event.preventDefault();

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('mousemove', onWindowMouseMove);
            };

            // when window is resized
            const onWindowResize = function(event) {
                fit();

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('resize', onWindowResize);
            };

            // attach the necessary event listeners
            img.addEventListener('dblclick', fit);
            img.addEventListener('mousedown', onImageMouseDown);
            container.addEventListener('wheel', onContainerWheel);
            container.addEventListener('mousedown', onContainerClick);
            container.addEventListener('touchstart', onContainerClick);
            window.addEventListener('mouseup', onWindowMouseUp);
            window.addEventListener('mousemove', onWindowMouseMove);
            window.addEventListener('resize', onWindowResize);

            // run fit() after lightbox atttached to document and <img> Loaded
            // so needed container and img dimensions available
            img.addEventListener('load', fit);

            return img;
        }

        // make caption
        function makeCaption(img) {
            const caption = document.createElement('div');
            caption.id = 'lightbox_caption';
            const captionSource = img.nextElementSibling;
            if (captionSource.tagName.toLowerCase() === 'figcaption') {
                const captionCopy = makeCopy(captionSource);
                caption.innerHTML = captionCopy.innerHTML;
            }

            caption.addEventListener('touchstart', function(event) {
                event.stopPropagation();
            });

            return caption;
        }

        // make carbon copy of html dom element
        function makeCopy(source) {
            const sourceCopy = source.cloneNode(true);

            // delete elements marked with ignore (eg anchor and jump buttons)
            const deleteFromCopy = sourceCopy.querySelectorAll(
                '[data-ignore="true"]'
            );
            for (const element of deleteFromCopy)
                element.remove();

            // delete certain element attributes
            const attributes = [
                'id',
                'data-collapsed',
                'data-selected',
                'data-highlighted',
                'data-glow'
            ];
            for (const attribute of attributes) {
                sourceCopy.removeAttribute(attribute);
                const elements = sourceCopy.querySelectorAll(
                    '[' + attribute + ']'
                );
                for (const element of elements)
                    element.removeAttribute(attribute);
            }

            return sourceCopy;
        }

        // make button to jump to previous image in document
        function makePrevButton(img) {
            const prevButton = document.createElement('button');
            prevButton.id = 'lightbox_prev_button';
            prevButton.title = 'Jump to the previous image in the document [←]';
            prevButton.classList.add('icon_button', 'lightbox_button');
            prevButton.innerHTML = document.querySelector(
                '.icon_caret_left'
            ).innerHTML;

            // attach click listeners to button
            prevButton.addEventListener('click', function() {
                getPrevImg(img).click();
            });

            return prevButton;
        }

        // make button to jump to next image in document
        function makeNextButton(img) {
            const nextButton = document.createElement('button');
            nextButton.id = 'lightbox_next_button';
            nextButton.title = 'Jump to the next image in the document [→]';
            nextButton.classList.add('icon_button', 'lightbox_button');
            nextButton.innerHTML = document.querySelector(
                '.icon_caret_right'
            ).innerHTML;

            // attach click listeners to button
            nextButton.addEventListener('click', function() {
                getNextImg(img).click();
            });

            return nextButton;
        }

        // get previous image in document
        function getPrevImg(img) {
            const imgs = document.querySelectorAll('.lightbox_document_img');

            // find index of provided img
            let index;
            for (index = 0; index < imgs.length; index++) {
                if (imgs[index] === img)
                    break;
            }


            // wrap index to other side if < 1
            if (index - 1 >= 0)
                index--;
            else
                index = imgs.length - 1;
            return imgs[index];
        }

        // get next image in document
        function getNextImg(img) {
            const imgs = document.querySelectorAll('.lightbox_document_img');

            // find index of provided img
            let index;
            for (index = 0; index < imgs.length; index++) {
                if (imgs[index] === img)
                    break;
            }


            // wrap index to other side if > total
            if (index + 1 <= imgs.length - 1)
                index++;
            else
                index = 0;
            return imgs[index];
        }

        // close lightbox
        function closeLightbox() {
            focusBody();

            const lightbox = document.getElementById('lightbox_overlay');
            if (lightbox)
                lightbox.remove();
        }

        // make all elements behind lightbox non-focusable
        function blurBody(overlay) {
            const all = document.querySelectorAll('*');
            for (const element of all)
                element.tabIndex = -1;
            document.body.classList.add('body_no_scroll');
        }

        // make all elements focusable again
        function focusBody() {
            const all = document.querySelectorAll('*');
            for (const element of all)
                element.removeAttribute('tabIndex');
            document.body.classList.remove('body_no_scroll');
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- caret left icon -->

<template class="icon_caret_left">
    <!-- modified from: https://fontawesome.com/icons/caret-left -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M192 127.338v257.324c0 17.818-21.543 26.741-34.142 14.142L29.196 270.142c-7.81-7.81-7.81-20.474 0-28.284l128.662-128.662c12.599-12.6 34.142-3.676 34.142 14.142z"
        ></path>
    </svg>
</template>

<!-- caret right icon -->

<template class="icon_caret_right">
    <!-- modified from: https://fontawesome.com/icons/caret-right -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z"
        ></path>
    </svg>
</template>
<!-- attributes plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin allows arbitrary HTML attributes to be attached
        // to (almost) any element. Place an HTML comment inside or next to the
        // desired element in the format <!-- $attribute="value" -->

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'attributes';

        // default plugin options
        const options = {
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // get list of comments in document
            const comments = findComments();

            for(const comment of comments)
                if (comment.parentElement)
                    addAttributes(
                        comment.parentElement,
                        comment.nodeValue.trim()
                    );
        }

        // add html attributes to specified element based on string of 
        // html attributes and values
        function addAttributes(element, text) {
            // regex's for finding attribute/value pairs in the format of
            // attribute="value" or attribute='value
            const regex2 = /\$([a-zA-Z\-]+)?=\"(.+?)\"/;
            const regex1 = /\$([a-zA-Z\-]+)?=\'(.+?)\'/;

            // loop through attribute/value pairs
            let match;
            while(match = text.match(regex2) || text.match(regex1)) {
                // get attribute and value from regex capture groups
                let attribute = match[1];
                let value = match[2];

                // remove from string
                text = text.substring(match.index + match[0].length);

                if (!attribute || !value)
                    break;

                // set attribute of parent element
                try {
                    element.setAttribute(attribute, value);
                } catch(error) {
                    console.log(error);
                }

                // special case for colspan
                if (attribute === 'colspan')
                    removeTableCells(element, value);
            }
        }

        // get list of comment elements in document
        function findComments() {
            const comments = [];

            // iterate over comment nodes in document
            function acceptNode(node) {
                return NodeFilter.FILTER_ACCEPT;
            }
            const iterator = document.createNodeIterator(
                document.body,
                NodeFilter.SHOW_COMMENT,
                acceptNode
            );
            let node;
            while(node = iterator.nextNode())
                comments.push(node);

            return comments;
        }

        // remove certain number of cells after specified cell
        function removeTableCells(cell, number) {
            number = parseInt(number);
            if (!number)
                return;

            // remove elements
            for(; number > 1; number--) {
                if (cell.nextElementSibling)
                    cell.nextElementSibling.remove();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>
<!-- math plugin configuration -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        "CommonHTML": { linebreaks: { automatic: true } },
        "HTML-CSS": { linebreaks: { automatic: true } },
        "SVG": { linebreaks: { automatic: true } },
        "fast-preview": { disabled: true }
    });
</script>

<!-- math plugin -->

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML'>
    // /////////////////////////
    // DESCRIPTION
    // /////////////////////////

    // This third-party plugin 'MathJax' allows the proper rendering of
    // math/equations written in LaTeX.

    // https://www.mathjax.org/
</script>
<!-- annotations plugin configuration -->

<script>
    window.hypothesisConfig = function() {
        return {
            branding: {
                accentColor: '#2196f3',
                appBackgroundColor: '#f8f8f8',
                ctaBackgroundColor: '#f8f8f8',
                ctaTextColor: '#000000',
                selectionFontFamily: 'Open Sans, Helvetica, sans serif',
                annotationFontFamily: 'Open Sans, Helvetica, sans serif'
            }
        };
    };
</script>

<!-- annotations plugin -->

<script src='https://hypothes.is/embed.js'>
    // /////////////////////////
    // DESCRIPTION
    // /////////////////////////

    // This third-party plugin 'Hypothesis' allows public annotation of the
    // manuscript.

    // https://web.hypothes.is/
</script>
</body>
</html>
